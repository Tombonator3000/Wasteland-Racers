<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WASTELAND RACERS - Zone Editor</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #111;
    color: #ccc;
    font-family: 'Courier New', monospace;
    display: flex;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }

  /* --- Sidebar --- */
  #sidebar {
    width: 280px;
    background: #1a1a1a;
    border-right: 2px solid #333;
    padding: 12px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    overflow-y: auto;
  }
  #sidebar h1 {
    color: #ff6600;
    font-size: 16px;
    text-align: center;
    border-bottom: 1px solid #333;
    padding-bottom: 8px;
  }
  #sidebar h2 {
    color: #aa6633;
    font-size: 12px;
    margin-top: 6px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .btn {
    background: #2a2a2a;
    border: 1px solid #444;
    color: #ccc;
    padding: 8px 12px;
    cursor: pointer;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    text-align: left;
    transition: background 0.15s;
  }
  .btn:hover { background: #3a3a3a; }
  .btn.active { background: #553300; border-color: #ff6600; color: #ff6600; }
  .btn-row { display: flex; gap: 4px; }
  .btn-row .btn { flex: 1; text-align: center; }

  .btn-primary {
    background: #663300;
    border-color: #ff6600;
    color: #ff6600;
  }
  .btn-primary:hover { background: #884400; }

  .btn-danger {
    background: #330000;
    border-color: #aa0000;
    color: #ff4444;
  }
  .btn-danger:hover { background: #550000; }

  .zone-btn {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .zone-color {
    width: 16px;
    height: 16px;
    border: 1px solid #666;
    flex-shrink: 0;
  }

  .slider-group {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 11px;
  }
  .slider-group input[type="range"] {
    flex: 1;
    accent-color: #ff6600;
  }
  .slider-group span {
    min-width: 24px;
    text-align: right;
    color: #ff6600;
  }

  label {
    font-size: 11px;
    color: #888;
  }
  input[type="text"], input[type="number"] {
    background: #222;
    border: 1px solid #444;
    color: #ccc;
    padding: 4px 8px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    width: 100%;
  }

  .info-box {
    background: #1e1e1a;
    border: 1px solid #333;
    padding: 8px;
    font-size: 10px;
    color: #888;
    line-height: 1.5;
  }

  .shortcut { color: #666; font-size: 10px; }

  /* --- Canvas area --- */
  #canvas-area {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #0a0a0a;
    position: relative;
  }
  #editor-canvas {
    cursor: crosshair;
    image-rendering: pixelated;
  }

  /* --- Status bar --- */
  #statusbar {
    position: fixed;
    bottom: 0;
    left: 280px;
    right: 0;
    height: 28px;
    background: #1a1a1a;
    border-top: 1px solid #333;
    display: flex;
    align-items: center;
    padding: 0 12px;
    font-size: 11px;
    color: #888;
    gap: 20px;
  }
  #statusbar .status-item { display: flex; gap: 4px; }
  #statusbar .val { color: #ff6600; }

  /* Waypoint list */
  .waypoint-list {
    max-height: 120px;
    overflow-y: auto;
    font-size: 10px;
  }
  .waypoint-item {
    display: flex;
    justify-content: space-between;
    padding: 2px 4px;
    border-bottom: 1px solid #222;
  }
  .waypoint-item:hover { background: #222; }
  .wp-delete {
    color: #aa0000;
    cursor: pointer;
    font-weight: bold;
  }
  .wp-delete:hover { color: #ff0000; }
</style>
</head>
<body>

<!-- Sidebar -->
<div id="sidebar">
  <h1>WASTELAND RACERS<br>ZONE EDITOR</h1>

  <!-- Image loading -->
  <h2>Background Image</h2>
  <input type="file" id="bg-input" accept="image/*" style="font-size:10px; color:#888;">
  <div class="btn-row">
    <button class="btn" id="btn-clear-bg">Clear BG</button>
    <button class="btn" id="btn-fit-bg">Fit to Canvas</button>
  </div>
  <div class="slider-group">
    <label>BG Opacity</label>
    <input type="range" id="bg-opacity" min="10" max="100" value="70">
    <span id="bg-opacity-val">70%</span>
  </div>

  <!-- Grid settings -->
  <h2>Grid</h2>
  <div class="btn-row">
    <div>
      <label>Cols</label>
      <input type="number" id="grid-cols" value="60" min="10" max="200" style="width:60px">
    </div>
    <div>
      <label>Rows</label>
      <input type="number" id="grid-rows" value="46" min="10" max="200" style="width:60px">
    </div>
    <button class="btn" id="btn-apply-grid" style="align-self:end">Apply</button>
  </div>
  <div class="slider-group">
    <label>Grid Opacity</label>
    <input type="range" id="grid-opacity" min="0" max="100" value="30">
    <span id="grid-opacity-val">30%</span>
  </div>

  <!-- Zone tools -->
  <h2>Zone Paint Tool</h2>
  <button class="btn zone-btn active" data-zone="track">
    <div class="zone-color" style="background:rgba(0,180,0,0.5)"></div>
    [1] Track (driveable)
  </button>
  <button class="btn zone-btn" data-zone="wall">
    <div class="zone-color" style="background:rgba(180,0,0,0.5)"></div>
    [2] Wall (barrier)
  </button>
  <button class="btn zone-btn" data-zone="hazard">
    <div class="zone-color" style="background:rgba(180,180,0,0.5)"></div>
    [3] Hazard (slow/damage)
  </button>
  <button class="btn zone-btn" data-zone="boost">
    <div class="zone-color" style="background:rgba(0,150,255,0.5)"></div>
    [4] Boost zone
  </button>
  <button class="btn zone-btn" data-zone="pit">
    <div class="zone-color" style="background:rgba(150,0,180,0.5)"></div>
    [5] Pit stop (repair)
  </button>
  <button class="btn zone-btn" data-zone="eraser">
    <div class="zone-color" style="background:rgba(255,255,255,0.2)"></div>
    [E] Eraser
  </button>

  <div class="slider-group">
    <label>Brush Size</label>
    <input type="range" id="brush-size" min="1" max="10" value="2">
    <span id="brush-size-val">2</span>
  </div>

  <!-- Waypoint mode -->
  <h2>AI Waypoints [W]</h2>
  <div class="btn-row">
    <button class="btn" id="btn-waypoint-mode">Place Waypoints</button>
    <button class="btn btn-danger" id="btn-clear-waypoints">Clear All</button>
  </div>
  <div class="waypoint-list" id="waypoint-list"></div>

  <!-- Start positions -->
  <h2>Start Positions [S]</h2>
  <div class="btn-row">
    <button class="btn" id="btn-start-mode">Place Starts</button>
    <button class="btn btn-danger" id="btn-clear-starts">Clear</button>
  </div>
  <div class="info-box" id="start-info">No start positions set.</div>

  <!-- Start/Finish line -->
  <h2>Start/Finish Line [F]</h2>
  <button class="btn" id="btn-finish-mode">Draw Finish Line</button>
  <div class="info-box" id="finish-info">Click two points to define the start/finish line.</div>

  <!-- Track metadata -->
  <h2>Track Info</h2>
  <label>Track Name</label>
  <input type="text" id="track-name" value="Untitled Track" placeholder="Track name...">
  <label>Laps</label>
  <input type="number" id="track-laps" value="3" min="1" max="20" style="width:60px">

  <!-- Export/Import -->
  <h2>File</h2>
  <div class="btn-row">
    <button class="btn btn-primary" id="btn-export">Export JSON</button>
    <button class="btn btn-primary" id="btn-import">Import JSON</button>
  </div>
  <input type="file" id="import-input" accept=".json" style="display:none">
  <div class="btn-row">
    <button class="btn" id="btn-export-full">Export with Image</button>
  </div>
  <div class="btn-row">
    <button class="btn btn-danger" id="btn-clear-all">Clear Everything</button>
  </div>

  <!-- Help -->
  <div class="info-box">
    <strong>Shortcuts:</strong><br>
    1-5: Zone tools | E: Eraser<br>
    W: Waypoint mode | S: Start mode<br>
    F: Finish line mode<br>
    [/]: Brush size -/+<br>
    G: Toggle grid | Z: Undo<br>
    Hold SHIFT: Straight line<br>
    Mouse wheel: Brush size
  </div>
</div>

<!-- Canvas -->
<div id="canvas-area">
  <canvas id="editor-canvas"></canvas>
</div>

<!-- Status bar -->
<div id="statusbar">
  <div class="status-item">Mode: <span class="val" id="status-mode">Paint</span></div>
  <div class="status-item">Zone: <span class="val" id="status-zone">track</span></div>
  <div class="status-item">Brush: <span class="val" id="status-brush">2</span></div>
  <div class="status-item">Cell: <span class="val" id="status-cell">-</span></div>
  <div class="status-item">Waypoints: <span class="val" id="status-wp">0</span></div>
  <div class="status-item">Starts: <span class="val" id="status-starts">0</span></div>
</div>

<script>
// ============================================================
// WASTELAND RACERS - Zone Editor
// ============================================================

const canvas = document.getElementById('editor-canvas');
const ctx = canvas.getContext('2d');

// --- State ---
let gridCols = 60;
let gridRows = 46;
let cellW, cellH;
const CANVAS_W = 900;
const CANVAS_H = 700;
canvas.width = CANVAS_W;
canvas.height = CANVAS_H;

// Grid data: 0=empty, 'track', 'wall', 'hazard', 'boost', 'pit'
let grid = [];
let undoStack = [];
const MAX_UNDO = 50;

// Background image
let bgImage = null;
let bgOpacity = 0.7;
let gridOpacity = 0.3;
let showGrid = true;

// Tools
let currentZone = 'track';
let brushSize = 2;
let mode = 'paint'; // 'paint', 'waypoint', 'start', 'finish'
let isPainting = false;
let lastCell = null;

// Waypoints for AI
let waypoints = [];

// Start positions
let startPositions = [];

// Finish line
let finishLine = null; // {x1,y1,x2,y2}
let finishFirstPoint = null;

// Zone colors
const ZONE_COLORS = {
  track:  'rgba(0, 180, 0, 0.45)',
  wall:   'rgba(180, 0, 0, 0.45)',
  hazard: 'rgba(180, 180, 0, 0.45)',
  boost:  'rgba(0, 150, 255, 0.45)',
  pit:    'rgba(150, 0, 180, 0.45)',
};

// --- Init grid ---
function initGrid() {
  grid = [];
  for (let r = 0; r < gridRows; r++) {
    grid[r] = [];
    for (let c = 0; c < gridCols; c++) {
      grid[r][c] = 0;
    }
  }
  cellW = CANVAS_W / gridCols;
  cellH = CANVAS_H / gridRows;
}
initGrid();

// --- Undo ---
function saveUndoState() {
  const state = grid.map(row => [...row]);
  undoStack.push(state);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
}

function undo() {
  if (undoStack.length === 0) return;
  grid = undoStack.pop();
  render();
}

// --- Background Image ---
document.getElementById('bg-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    const img = new Image();
    img.onload = () => {
      bgImage = img;
      render();
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
});

document.getElementById('btn-clear-bg').addEventListener('click', () => {
  bgImage = null;
  render();
});

document.getElementById('btn-fit-bg').addEventListener('click', () => {
  // Already fits to canvas by default
  render();
});

document.getElementById('bg-opacity').addEventListener('input', (e) => {
  bgOpacity = e.target.value / 100;
  document.getElementById('bg-opacity-val').textContent = e.target.value + '%';
  render();
});

document.getElementById('grid-opacity').addEventListener('input', (e) => {
  gridOpacity = e.target.value / 100;
  document.getElementById('grid-opacity-val').textContent = e.target.value + '%';
  render();
});

// --- Grid settings ---
document.getElementById('btn-apply-grid').addEventListener('click', () => {
  const newCols = parseInt(document.getElementById('grid-cols').value) || 60;
  const newRows = parseInt(document.getElementById('grid-rows').value) || 46;
  if (newCols !== gridCols || newRows !== gridRows) {
    if (confirm('Changing grid size will clear zone data. Continue?')) {
      gridCols = Math.max(10, Math.min(200, newCols));
      gridRows = Math.max(10, Math.min(200, newRows));
      initGrid();
      undoStack = [];
      render();
    }
  }
});

// --- Zone buttons ---
document.querySelectorAll('.zone-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.zone-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentZone = btn.dataset.zone;
    mode = 'paint';
    updateStatus();
  });
});

// --- Brush size ---
document.getElementById('brush-size').addEventListener('input', (e) => {
  brushSize = parseInt(e.target.value);
  document.getElementById('brush-size-val').textContent = brushSize;
  updateStatus();
});

// --- Mode buttons ---
document.getElementById('btn-waypoint-mode').addEventListener('click', () => {
  mode = mode === 'waypoint' ? 'paint' : 'waypoint';
  document.getElementById('btn-waypoint-mode').classList.toggle('active', mode === 'waypoint');
  document.getElementById('btn-start-mode').classList.remove('active');
  document.getElementById('btn-finish-mode').classList.remove('active');
  updateStatus();
});

document.getElementById('btn-start-mode').addEventListener('click', () => {
  mode = mode === 'start' ? 'paint' : 'start';
  document.getElementById('btn-start-mode').classList.toggle('active', mode === 'start');
  document.getElementById('btn-waypoint-mode').classList.remove('active');
  document.getElementById('btn-finish-mode').classList.remove('active');
  updateStatus();
});

document.getElementById('btn-finish-mode').addEventListener('click', () => {
  mode = mode === 'finish' ? 'paint' : 'finish';
  finishFirstPoint = null;
  document.getElementById('btn-finish-mode').classList.toggle('active', mode === 'finish');
  document.getElementById('btn-waypoint-mode').classList.remove('active');
  document.getElementById('btn-start-mode').classList.remove('active');
  updateStatus();
});

document.getElementById('btn-clear-waypoints').addEventListener('click', () => {
  waypoints = [];
  updateWaypointList();
  render();
});

document.getElementById('btn-clear-starts').addEventListener('click', () => {
  startPositions = [];
  updateStartInfo();
  render();
});

// --- Painting ---
function getCellFromMouse(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = CANVAS_W / rect.width;
  const scaleY = CANVAS_H / rect.height;
  const mx = (e.clientX - rect.left) * scaleX;
  const my = (e.clientY - rect.top) * scaleY;
  const col = Math.floor(mx / cellW);
  const row = Math.floor(my / cellH);
  return { col, row, px: mx, py: my };
}

function paintCell(col, row) {
  const half = Math.floor(brushSize / 2);
  for (let dr = -half; dr < brushSize - half; dr++) {
    for (let dc = -half; dc < brushSize - half; dc++) {
      const r = row + dr;
      const c = col + dc;
      if (r >= 0 && r < gridRows && c >= 0 && c < gridCols) {
        if (currentZone === 'eraser') {
          grid[r][c] = 0;
        } else {
          grid[r][c] = currentZone;
        }
      }
    }
  }
}

// Bresenham line for smooth painting
function paintLine(c0, r0, c1, r1) {
  const dx = Math.abs(c1 - c0);
  const dy = Math.abs(r1 - r0);
  const sx = c0 < c1 ? 1 : -1;
  const sy = r0 < r1 ? 1 : -1;
  let err = dx - dy;

  while (true) {
    paintCell(c0, r0);
    if (c0 === c1 && r0 === r1) break;
    const e2 = 2 * err;
    if (e2 > -dy) { err -= dy; c0 += sx; }
    if (e2 < dx) { err += dx; r0 += sy; }
  }
}

canvas.addEventListener('mousedown', (e) => {
  const cell = getCellFromMouse(e);

  if (mode === 'paint') {
    saveUndoState();
    isPainting = true;
    paintCell(cell.col, cell.row);
    lastCell = cell;
    render();
  } else if (mode === 'waypoint') {
    waypoints.push({ x: cell.px, y: cell.py });
    updateWaypointList();
    render();
  } else if (mode === 'start') {
    if (startPositions.length < 4) {
      startPositions.push({ x: cell.px, y: cell.py, angle: 0 });
      updateStartInfo();
      render();
    }
  } else if (mode === 'finish') {
    if (!finishFirstPoint) {
      finishFirstPoint = { x: cell.px, y: cell.py };
      document.getElementById('finish-info').textContent = 'Click second point...';
    } else {
      finishLine = {
        x1: finishFirstPoint.x, y1: finishFirstPoint.y,
        x2: cell.px, y2: cell.py
      };
      finishFirstPoint = null;
      document.getElementById('finish-info').textContent =
        `Line: (${Math.round(finishLine.x1)},${Math.round(finishLine.y1)}) to (${Math.round(finishLine.x2)},${Math.round(finishLine.y2)})`;
      render();
    }
  }
});

canvas.addEventListener('mousemove', (e) => {
  const cell = getCellFromMouse(e);
  document.getElementById('status-cell').textContent = `${cell.col},${cell.row}`;

  if (isPainting && mode === 'paint') {
    if (lastCell) {
      paintLine(lastCell.col, lastCell.row, cell.col, cell.row);
    } else {
      paintCell(cell.col, cell.row);
    }
    lastCell = cell;
    render();
  }
});

canvas.addEventListener('mouseup', () => {
  isPainting = false;
  lastCell = null;
});

canvas.addEventListener('mouseleave', () => {
  isPainting = false;
  lastCell = null;
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  brushSize = Math.max(1, Math.min(10, brushSize + (e.deltaY > 0 ? -1 : 1)));
  document.getElementById('brush-size').value = brushSize;
  document.getElementById('brush-size-val').textContent = brushSize;
  updateStatus();
});

// --- Keyboard shortcuts ---
document.addEventListener('keydown', (e) => {
  // Don't capture if typing in input
  if (e.target.tagName === 'INPUT') return;

  switch(e.key) {
    case '1': selectZone('track'); break;
    case '2': selectZone('wall'); break;
    case '3': selectZone('hazard'); break;
    case '4': selectZone('boost'); break;
    case '5': selectZone('pit'); break;
    case 'e': case 'E': selectZone('eraser'); break;
    case 'w': case 'W':
      document.getElementById('btn-waypoint-mode').click();
      break;
    case 's': case 'S':
      document.getElementById('btn-start-mode').click();
      break;
    case 'f': case 'F':
      document.getElementById('btn-finish-mode').click();
      break;
    case 'g': case 'G':
      showGrid = !showGrid;
      render();
      break;
    case 'z': case 'Z':
      if (e.ctrlKey || e.metaKey) { undo(); e.preventDefault(); }
      break;
    case '[':
      brushSize = Math.max(1, brushSize - 1);
      document.getElementById('brush-size').value = brushSize;
      document.getElementById('brush-size-val').textContent = brushSize;
      updateStatus();
      break;
    case ']':
      brushSize = Math.min(10, brushSize + 1);
      document.getElementById('brush-size').value = brushSize;
      document.getElementById('brush-size-val').textContent = brushSize;
      updateStatus();
      break;
  }
});

function selectZone(zone) {
  currentZone = zone;
  mode = 'paint';
  document.querySelectorAll('.zone-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.zone === zone);
  });
  document.getElementById('btn-waypoint-mode').classList.remove('active');
  document.getElementById('btn-start-mode').classList.remove('active');
  document.getElementById('btn-finish-mode').classList.remove('active');
  updateStatus();
}

// --- Render ---
function render() {
  ctx.clearRect(0, 0, CANVAS_W, CANVAS_H);

  // Background
  ctx.fillStyle = '#1a1a12';
  ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

  // Background image
  if (bgImage) {
    ctx.globalAlpha = bgOpacity;
    ctx.drawImage(bgImage, 0, 0, CANVAS_W, CANVAS_H);
    ctx.globalAlpha = 1;
  }

  // Zone overlay
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const zone = grid[r][c];
      if (zone && ZONE_COLORS[zone]) {
        ctx.fillStyle = ZONE_COLORS[zone];
        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
      }
    }
  }

  // Grid
  if (showGrid && gridOpacity > 0) {
    ctx.strokeStyle = `rgba(255,255,255,${gridOpacity})`;
    ctx.lineWidth = 0.5;
    for (let c = 0; c <= gridCols; c++) {
      ctx.beginPath();
      ctx.moveTo(c * cellW, 0);
      ctx.lineTo(c * cellW, CANVAS_H);
      ctx.stroke();
    }
    for (let r = 0; r <= gridRows; r++) {
      ctx.beginPath();
      ctx.moveTo(0, r * cellH);
      ctx.lineTo(CANVAS_W, r * cellH);
      ctx.stroke();
    }
  }

  // Waypoints
  for (let i = 0; i < waypoints.length; i++) {
    const wp = waypoints[i];
    // Line to next waypoint
    if (i < waypoints.length - 1) {
      ctx.strokeStyle = 'rgba(255, 200, 0, 0.4)';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(wp.x, wp.y);
      ctx.lineTo(waypoints[i + 1].x, waypoints[i + 1].y);
      ctx.stroke();
      ctx.setLineDash([]);
    }
    // Line from last to first (loop)
    if (i === waypoints.length - 1 && waypoints.length > 2) {
      ctx.strokeStyle = 'rgba(255, 200, 0, 0.2)';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(wp.x, wp.y);
      ctx.lineTo(waypoints[0].x, waypoints[0].y);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Dot
    ctx.fillStyle = '#ffcc00';
    ctx.beginPath();
    ctx.arc(wp.x, wp.y, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#aa8800';
    ctx.lineWidth = 1;
    ctx.stroke();

    // Index label
    ctx.fillStyle = '#000';
    ctx.font = 'bold 9px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(i.toString(), wp.x, wp.y + 3);
    ctx.textAlign = 'left';
  }

  // Start positions
  for (let i = 0; i < startPositions.length; i++) {
    const sp = startPositions[i];
    ctx.save();
    ctx.translate(sp.x, sp.y);

    // Car shape
    ctx.fillStyle = ['#cc3300', '#3366cc', '#33aa33', '#aa33aa'][i] || '#ccc';
    ctx.fillRect(-10, -6, 20, 12);
    ctx.fillStyle = '#000';
    ctx.font = 'bold 10px monospace';
    ctx.textAlign = 'center';
    ctx.fillText('P' + (i + 1), 0, 4);
    ctx.textAlign = 'left';

    ctx.restore();
  }

  // Finish line
  if (finishLine) {
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(finishLine.x1, finishLine.y1);
    ctx.lineTo(finishLine.x2, finishLine.y2);
    ctx.stroke();

    // Checkerboard pattern
    const dx = finishLine.x2 - finishLine.x1;
    const dy = finishLine.y2 - finishLine.y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const steps = Math.floor(len / 8);
    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const px = finishLine.x1 + dx * t;
      const py = finishLine.y1 + dy * t;
      ctx.fillStyle = i % 2 === 0 ? '#fff' : '#000';
      ctx.fillRect(px - 3, py - 3, 6, 6);
    }
  }

  // Finish line first point indicator
  if (finishFirstPoint) {
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(finishFirstPoint.x, finishFirstPoint.y, 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- UI Updates ---
function updateStatus() {
  document.getElementById('status-mode').textContent =
    mode === 'paint' ? 'Paint' : mode === 'waypoint' ? 'Waypoint' : mode === 'start' ? 'Start' : 'Finish';
  document.getElementById('status-zone').textContent = currentZone;
  document.getElementById('status-brush').textContent = brushSize;
  document.getElementById('status-wp').textContent = waypoints.length;
  document.getElementById('status-starts').textContent = startPositions.length;
}

function updateWaypointList() {
  const list = document.getElementById('waypoint-list');
  list.innerHTML = '';
  waypoints.forEach((wp, i) => {
    const item = document.createElement('div');
    item.className = 'waypoint-item';
    item.innerHTML = `
      <span>#${i} (${Math.round(wp.x)}, ${Math.round(wp.y)})</span>
      <span class="wp-delete" data-idx="${i}">X</span>
    `;
    list.appendChild(item);
  });
  list.querySelectorAll('.wp-delete').forEach(btn => {
    btn.addEventListener('click', (e) => {
      const idx = parseInt(e.target.dataset.idx);
      waypoints.splice(idx, 1);
      updateWaypointList();
      render();
    });
  });
  document.getElementById('status-wp').textContent = waypoints.length;
}

function updateStartInfo() {
  const info = document.getElementById('start-info');
  if (startPositions.length === 0) {
    info.textContent = 'No start positions set.';
  } else {
    info.textContent = startPositions.map((sp, i) =>
      `P${i + 1}: (${Math.round(sp.x)}, ${Math.round(sp.y)})`
    ).join(' | ');
  }
  document.getElementById('status-starts').textContent = startPositions.length;
}

// --- Export ---
document.getElementById('btn-export').addEventListener('click', () => {
  const trackData = {
    version: 1,
    name: document.getElementById('track-name').value,
    laps: parseInt(document.getElementById('track-laps').value) || 3,
    canvas: { width: CANVAS_W, height: CANVAS_H },
    grid: {
      cols: gridCols,
      rows: gridRows,
      data: grid
    },
    waypoints: waypoints,
    startPositions: startPositions,
    finishLine: finishLine,
    backgroundImage: null
  };

  const json = JSON.stringify(trackData, null, 2);
  downloadFile(json, (trackData.name || 'track') + '.json', 'application/json');
});

document.getElementById('btn-export-full').addEventListener('click', () => {
  // Export with embedded background image as base64
  let bgBase64 = null;
  if (bgImage) {
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = CANVAS_W;
    tempCanvas.height = CANVAS_H;
    const tempCtx = tempCanvas.getContext('2d');
    tempCtx.drawImage(bgImage, 0, 0, CANVAS_W, CANVAS_H);
    bgBase64 = tempCanvas.toDataURL('image/png');
  }

  const trackData = {
    version: 1,
    name: document.getElementById('track-name').value,
    laps: parseInt(document.getElementById('track-laps').value) || 3,
    canvas: { width: CANVAS_W, height: CANVAS_H },
    grid: {
      cols: gridCols,
      rows: gridRows,
      data: grid
    },
    waypoints: waypoints,
    startPositions: startPositions,
    finishLine: finishLine,
    backgroundImage: bgBase64
  };

  const json = JSON.stringify(trackData);
  downloadFile(json, (trackData.name || 'track') + '_full.json', 'application/json');
});

function downloadFile(content, filename, type) {
  const blob = new Blob([content], { type });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

// --- Import ---
document.getElementById('btn-import').addEventListener('click', () => {
  document.getElementById('import-input').click();
});

document.getElementById('import-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      loadTrackData(data);
    } catch (err) {
      alert('Invalid track file: ' + err.message);
    }
  };
  reader.readAsText(file);
});

function loadTrackData(data) {
  if (data.grid) {
    gridCols = data.grid.cols;
    gridRows = data.grid.rows;
    document.getElementById('grid-cols').value = gridCols;
    document.getElementById('grid-rows').value = gridRows;
    cellW = CANVAS_W / gridCols;
    cellH = CANVAS_H / gridRows;
    grid = data.grid.data;
  }
  if (data.waypoints) waypoints = data.waypoints;
  if (data.startPositions) startPositions = data.startPositions;
  if (data.finishLine) finishLine = data.finishLine;
  if (data.name) document.getElementById('track-name').value = data.name;
  if (data.laps) document.getElementById('track-laps').value = data.laps;

  if (data.backgroundImage) {
    const img = new Image();
    img.onload = () => {
      bgImage = img;
      render();
    };
    img.src = data.backgroundImage;
  }

  updateWaypointList();
  updateStartInfo();
  if (finishLine) {
    document.getElementById('finish-info').textContent =
      `Line: (${Math.round(finishLine.x1)},${Math.round(finishLine.y1)}) to (${Math.round(finishLine.x2)},${Math.round(finishLine.y2)})`;
  }
  render();
}

// --- Clear all ---
document.getElementById('btn-clear-all').addEventListener('click', () => {
  if (confirm('Clear everything? This cannot be undone.')) {
    initGrid();
    waypoints = [];
    startPositions = [];
    finishLine = null;
    finishFirstPoint = null;
    undoStack = [];
    bgImage = null;
    updateWaypointList();
    updateStartInfo();
    document.getElementById('finish-info').textContent = 'Click two points to define the start/finish line.';
    render();
  }
});

// --- Initial render ---
updateStatus();
render();
</script>
</body>
</html>
