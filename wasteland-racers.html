<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WASTELAND RACERS</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    font-family: monospace;
  }
  canvas {
    image-rendering: pixelated;
    border: 2px solid #333;
  }
  #ui-overlay {
    position: absolute;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    color: #ff6600;
    font-family: monospace;
    font-size: 14px;
    text-align: center;
    pointer-events: none;
    text-shadow: 0 0 6px rgba(255,100,0,0.5);
  }
  /* Hidden file input for track loading */
  #track-file-input {
    position: absolute;
    top: -9999px;
    left: -9999px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<input type="file" id="track-file-input" accept=".json">
<script>
// ========================================
// WASTELAND RACERS - Core Engine v2
// Inspired by Badlands (1990) & Super Off Road
// Now with JSON track loading & zone system
// ========================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Canvas sizing ---
const W = 900;
const H = 700;
canvas.width = W;
canvas.height = H;

// --- Game State ---
const STATE = {
  MENU: 0,
  COUNTDOWN: 1,
  RACING: 2,
  RESULTS: 3,
  SHOP: 4
};
let gameState = STATE.MENU;
let countdownTimer = 0;
let raceTime = 0;

// --- Track State ---
// All track data lives here - populated by default or from JSON
let trackState = {
  name: 'Wasteland Circuit',
  laps: 3,
  grid: { cols: 60, rows: 46, data: [] },
  waypoints: [],
  startPositions: [],
  finishLine: null,
  bgImage: null,
  cellW: 15,
  cellH: 700 / 46,
  isCustom: false
};

// ========================================
// DEFAULT TRACK GENERATION
// Uses cardinal spline to create a built-in track
// ========================================

const trackColor = '#4a3a2a';
const trackBorderColor = '#2a1a0a';
const groundColor = '#1a1a12';
const trackWidth = 70;

// Spline waypoints for the default built-in track
const defaultTrackPoints = [
  {x: 200, y: 120},
  {x: 380, y: 80},
  {x: 580, y: 80},
  {x: 720, y: 120},
  {x: 790, y: 200},
  {x: 810, y: 320},
  {x: 780, y: 440},
  {x: 700, y: 520},
  {x: 580, y: 560},
  {x: 460, y: 580},
  {x: 340, y: 600},
  {x: 200, y: 580},
  {x: 120, y: 500},
  {x: 100, y: 400},
  {x: 130, y: 300},
  {x: 160, y: 220},
  {x: 140, y: 160},
];

function getSplinePoints(pts, tension, numPerSeg) {
  tension = tension || 0.5;
  numPerSeg = numPerSeg || 20;
  const result = [];
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const p0 = pts[(i - 1 + n) % n];
    const p1 = pts[i];
    const p2 = pts[(i + 1) % n];
    const p3 = pts[(i + 2) % n];
    for (let t = 0; t < numPerSeg; t++) {
      const s = t / numPerSeg;
      const s2 = s * s;
      const s3 = s2 * s;
      const h1 = -tension * s + 2 * tension * s2 - tension * s3;
      const h2 = 1 + (tension - 3) * s2 + (2 - tension) * s3;
      const h3 = tension * s + (3 - 2 * tension) * s2 + (tension - 2) * s3;
      const h4 = -tension * s2 + tension * s3;
      result.push({
        x: p0.x * h1 + p1.x * h2 + p2.x * h3 + p3.x * h4,
        y: p0.y * h1 + p1.y * h2 + p2.y * h3 + p3.y * h4
      });
    }
  }
  return result;
}

function getTrackNormals(pts) {
  const normals = [];
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const next = pts[(i + 1) % n];
    const dx = next.x - pts[i].x;
    const dy = next.y - pts[i].y;
    const len = Math.sqrt(dx * dx + dy * dy);
    normals.push({ x: -dy / len, y: dx / len });
  }
  return normals;
}

// Generate default track from spline, converting to grid format
function generateDefaultTrack() {
  const smoothTrack = getSplinePoints(defaultTrackPoints, 0.5, 25);
  const normals = getTrackNormals(smoothTrack);
  const cols = 60;
  const rows = 46;
  const cw = W / cols;
  const ch = H / rows;
  const data = [];

  // Generate grid by checking distance to spline
  for (let r = 0; r < rows; r++) {
    data[r] = [];
    for (let c = 0; c < cols; c++) {
      const cx = c * cw + cw / 2;
      const cy = r * ch + ch / 2;
      let minDist = Infinity;
      for (let i = 0; i < smoothTrack.length; i++) {
        const dx = cx - smoothTrack[i].x;
        const dy = cy - smoothTrack[i].y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < minDist) minDist = d;
      }
      if (minDist < trackWidth * 0.95) {
        data[r][c] = 'track';
      } else if (minDist < trackWidth * 1.1) {
        data[r][c] = 'wall';
      } else {
        data[r][c] = 0;
      }
    }
  }

  // Add some hazard and boost zones for variety
  // Hazard zone near middle of track
  const hazardIdx = Math.floor(smoothTrack.length * 0.4);
  const hazPt = smoothTrack[hazardIdx];
  const hCol = Math.floor(hazPt.x / cw);
  const hRow = Math.floor(hazPt.y / ch);
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const rr = hRow + dr;
      const cc = hCol + dc;
      if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && data[rr][cc] === 'track') {
        data[rr][cc] = 'hazard';
      }
    }
  }

  // Boost zone on a straight section
  const boostIdx = Math.floor(smoothTrack.length * 0.15);
  const boostPt = smoothTrack[boostIdx];
  const bCol = Math.floor(boostPt.x / cw);
  const bRow = Math.floor(boostPt.y / ch);
  for (let dr = -1; dr <= 0; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      const rr = bRow + dr;
      const cc = bCol + dc;
      if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && data[rr][cc] === 'track') {
        data[rr][cc] = 'boost';
      }
    }
  }

  // Pit zone
  const pitIdx = Math.floor(smoothTrack.length * 0.7);
  const pitPt = smoothTrack[pitIdx];
  const pCol = Math.floor(pitPt.x / cw);
  const pRow = Math.floor(pitPt.y / ch);
  for (let dr = 0; dr <= 1; dr++) {
    for (let dc = -1; dc <= 0; dc++) {
      const rr = pRow + dr;
      const cc = pCol + dc;
      if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && data[rr][cc] === 'track') {
        data[rr][cc] = 'pit';
      }
    }
  }

  // Generate AI waypoints from spline (sample every Nth point)
  const wpSpacing = Math.floor(smoothTrack.length / 30);
  const waypoints = [];
  for (let i = 0; i < smoothTrack.length; i += wpSpacing) {
    waypoints.push({ x: smoothTrack[i].x, y: smoothTrack[i].y });
  }

  // Start positions
  const startPositions = [];
  for (let i = 0; i < 4; i++) {
    const idx = i * 3;
    const pt = smoothTrack[idx];
    const n = normals[idx];
    const nextPt = smoothTrack[(idx + 1) % smoothTrack.length];
    startPositions.push({
      x: pt.x + n.x * (i % 2 === 0 ? 15 : -15),
      y: pt.y + n.y * (i % 2 === 0 ? 15 : -15),
      angle: Math.atan2(nextPt.y - pt.y, nextPt.x - pt.x)
    });
  }

  // Finish line at start of track
  const startPt = smoothTrack[0];
  const startN = normals[0];
  const finishLine = {
    x1: startPt.x + startN.x * trackWidth,
    y1: startPt.y + startN.y * trackWidth,
    x2: startPt.x - startN.x * trackWidth,
    y2: startPt.y - startN.y * trackWidth,
  };

  trackState = {
    name: 'Wasteland Circuit',
    laps: 3,
    grid: { cols, rows, data },
    waypoints,
    startPositions,
    finishLine,
    bgImage: null,
    cellW: cw,
    cellH: ch,
    isCustom: false,
    // Keep spline data for default track rendering
    _smoothTrack: smoothTrack,
    _normals: normals
  };
}

// ========================================
// TRACK JSON LOADING
// ========================================

function loadTrackFromJSON(jsonStr) {
  try {
    const data = JSON.parse(jsonStr);
    if (!data.grid || !data.waypoints || !data.startPositions) {
      alert('Invalid track file: missing required data (grid, waypoints, startPositions)');
      return false;
    }

    const cols = data.grid.cols || 60;
    const rows = data.grid.rows || 46;

    trackState = {
      name: data.name || 'Custom Track',
      laps: data.laps || 3,
      grid: {
        cols: cols,
        rows: rows,
        data: data.grid.data
      },
      waypoints: data.waypoints,
      startPositions: data.startPositions,
      finishLine: data.finishLine || null,
      bgImage: null,
      cellW: W / cols,
      cellH: H / rows,
      isCustom: true
    };

    // Load background image if present
    if (data.backgroundImage) {
      const img = new Image();
      img.onload = () => {
        trackState.bgImage = img;
      };
      img.src = data.backgroundImage;
    }

    // Ensure we have enough start positions
    while (trackState.startPositions.length < 4) {
      const last = trackState.startPositions[trackState.startPositions.length - 1];
      trackState.startPositions.push({
        x: last.x + 20,
        y: last.y + 10,
        angle: last.angle || 0
      });
    }

    // Ensure we have a finish line
    if (!trackState.finishLine && trackState.waypoints.length >= 2) {
      const wp0 = trackState.waypoints[0];
      trackState.finishLine = {
        x1: wp0.x - 40, y1: wp0.y - 40,
        x2: wp0.x + 40, y2: wp0.y + 40
      };
    }

    return true;
  } catch (e) {
    alert('Error loading track: ' + e.message);
    return false;
  }
}

// File input handler
document.getElementById('track-file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    if (loadTrackFromJSON(ev.target.result)) {
      // Track loaded, start the race
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    }
  };
  reader.readAsText(file);
  e.target.value = ''; // Reset so same file can be loaded again
});

// ========================================
// GRID UTILITIES
// ========================================

function getZoneAt(x, y) {
  const col = Math.floor(x / trackState.cellW);
  const row = Math.floor(y / trackState.cellH);
  if (col < 0 || col >= trackState.grid.cols || row < 0 || row >= trackState.grid.rows) return 0;
  return trackState.grid.data[row][col] || 0;
}

// Line segment intersection test (for finish line crossing)
function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  const d1x = x2 - x1, d1y = y2 - y1;
  const d2x = x4 - x3, d2y = y4 - y3;
  const denom = d1x * d2y - d1y * d2x;
  if (Math.abs(denom) < 0.0001) return false;
  const t = ((x3 - x1) * d2y - (y3 - y1) * d2x) / denom;
  const u = ((x3 - x1) * d1y - (y3 - y1) * d1x) / denom;
  return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// Get crossing direction (positive = correct direction)
function getCrossingDirection(x1, y1, x2, y2, fl) {
  // Use cross product to determine direction of crossing
  const dx = x2 - x1;
  const dy = y2 - y1;
  const flDx = fl.x2 - fl.x1;
  const flDy = fl.y2 - fl.y1;
  return dx * flDy - dy * flDx;
}

// ========================================
// UTILITY FUNCTIONS
// ========================================

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function angleBetween(a, b) {
  return Math.atan2(b.y - a.y, b.x - a.x);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function normalizeAngle(a) {
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

// ========================================
// OBSTACLES & PICKUPS
// ========================================

const obstacles = [];
const pickups = [];

function generateObstacles() {
  obstacles.length = 0;
  pickups.length = 0;

  // Place mines on track zones
  let attempts = 0;
  let minesPlaced = 0;
  while (minesPlaced < 5 && attempts < 200) {
    const x = Math.random() * W;
    const y = Math.random() * H;
    if (getZoneAt(x, y) === 'track') {
      // Don't place near start positions
      let nearStart = false;
      for (const sp of trackState.startPositions) {
        if (dist({x, y}, sp) < 80) { nearStart = true; break; }
      }
      if (!nearStart) {
        obstacles.push({ x, y, type: 'mine', radius: 8, active: true });
        minesPlaced++;
      }
    }
    attempts++;
  }

  // Place wrench pickups on track
  attempts = 0;
  let wrenchesPlaced = 0;
  while (wrenchesPlaced < 3 && attempts < 200) {
    const x = Math.random() * W;
    const y = Math.random() * H;
    if (getZoneAt(x, y) === 'track') {
      let nearStart = false;
      for (const sp of trackState.startPositions) {
        if (dist({x, y}, sp) < 60) { nearStart = true; break; }
      }
      if (!nearStart) {
        pickups.push({ x, y, type: 'wrench', radius: 10, active: true });
        wrenchesPlaced++;
      }
    }
    attempts++;
  }
}

// ========================================
// CAR CLASS
// ========================================

class Car {
  constructor(color, name, isPlayer) {
    this.color = color;
    this.name = name;
    this.isPlayer = isPlayer;
    this.x = 0;
    this.y = 0;
    this.angle = 0;
    this.speed = 0;
    this.maxSpeed = 3.2;
    this.acceleration = 0.06;
    this.braking = 0.08;
    this.turnSpeed = 0.04;
    this.friction = 0.985;
    this.offTrackFriction = 0.94;
    this.width = 18;
    this.height = 12;
    this.lap = 0;
    this.finished = false;
    this.finishTime = 0;

    // Previous position for finish line detection
    this.prevX = 0;
    this.prevY = 0;

    // Combat
    this.ammo = 10;
    this.missiles = 0;
    this.cooldown = 0;
    this.missileCooldown = 0;
    this.health = 100;
    this.stunTimer = 0;
    this.respawnTimer = 0;

    // Upgrades
    this.speedUpgrade = 0;
    this.accelUpgrade = 0;
    this.tireUpgrade = 0;

    // AI
    this.aiTargetIndex = 0;
    this.aiSteerNoise = 0;
    this.aiPersonality = {
      aggression: 0.3 + Math.random() * 0.5,
      accuracy: 0.7 + Math.random() * 0.3,
      nitroFreq: 0.002 + Math.random() * 0.004
    };

    // Visual
    this.dustParticles = [];
    this.wrenches = 0;
    this.nitro = 3;
    this.nitroActive = false;
    this.nitroTimer = 0;

    // Position tracking
    this.position = 0;
    this.totalProgress = 0;
    this.waypointProgress = 0;
  }

  applyUpgrades() {
    this.maxSpeed = 3.2 + this.speedUpgrade * 0.3;
    this.acceleration = 0.06 + this.accelUpgrade * 0.01;
    this.turnSpeed = 0.04 + this.tireUpgrade * 0.005;
  }

  reset(index) {
    const sp = trackState.startPositions[index] || trackState.startPositions[0];
    this.x = sp.x;
    this.y = sp.y;
    this.prevX = sp.x;
    this.prevY = sp.y;
    this.angle = sp.angle || 0;
    this.speed = 0;
    this.lap = 0;
    this.finished = false;
    this.finishTime = 0;
    this.health = 100;
    this.stunTimer = 0;
    this.respawnTimer = 0;
    this.ammo = 10;
    this.totalProgress = 0;
    this.waypointProgress = 0;
    this.dustParticles = [];

    // AI: find nearest waypoint
    if (!this.isPlayer && trackState.waypoints.length > 0) {
      let minD = Infinity;
      let minI = 0;
      for (let i = 0; i < trackState.waypoints.length; i++) {
        const d = dist(this, trackState.waypoints[i]);
        if (d < minD) { minD = d; minI = i; }
      }
      this.aiTargetIndex = (minI + 2) % trackState.waypoints.length;
    }

    this.applyUpgrades();
  }

  update(keys, dt, cars, bullets) {
    if (this.respawnTimer > 0) {
      this.respawnTimer -= dt;
      if (this.respawnTimer <= 0) {
        this.health = 100;
        this.stunTimer = 0;
      }
      return;
    }
    if (this.stunTimer > 0) {
      this.stunTimer -= dt;
      this.speed *= 0.95;
      return;
    }
    if (this.finished) return;

    // Save previous position for finish line detection
    this.prevX = this.x;
    this.prevY = this.y;

    if (this.isPlayer) {
      this.updatePlayer(keys, dt, bullets, cars);
    } else {
      this.updateAI(dt, cars, bullets);
    }

    // Nitro
    if (this.nitroActive && this.nitroTimer > 0) {
      this.nitroTimer -= dt;
      this.speed = Math.min(this.speed + 0.12, this.maxSpeed * 1.5);
      if (this.nitroTimer <= 0) {
        this.nitroActive = false;
      }
    }

    // Physics
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;

    // Grid-based zone collision
    const zone = getZoneAt(this.x, this.y);
    this.applyZoneEffect(zone);

    // Apply base friction
    this.speed *= this.friction;

    // Clamp position
    this.x = Math.max(10, Math.min(W - 10, this.x));
    this.y = Math.max(10, Math.min(H - 10, this.y));

    // Finish line lap counting
    this.checkFinishLine();

    // Cooldown
    if (this.cooldown > 0) this.cooldown -= dt;
    if (this.missileCooldown > 0) this.missileCooldown -= dt;

    // Dust particles
    if (Math.abs(this.speed) > 1) {
      if (Math.random() < 0.3) {
        this.dustParticles.push({
          x: this.x - Math.cos(this.angle) * 10 + (Math.random() - 0.5) * 6,
          y: this.y - Math.sin(this.angle) * 10 + (Math.random() - 0.5) * 6,
          life: 20,
          maxLife: 20,
          size: 2 + Math.random() * 3
        });
      }
    }
    this.dustParticles = this.dustParticles.filter(p => {
      p.life--;
      return p.life > 0;
    });

    // Obstacle collision
    for (const obs of obstacles) {
      if (!obs.active) continue;
      if (dist(this, obs) < obs.radius + 10) {
        if (obs.type === 'mine') {
          this.health -= 30;
          this.stunTimer = 40;
          this.speed *= -0.3;
          obs.active = false;
          explosions.push(createExplosion(obs.x, obs.y));
          if (this.health <= 0) {
            this.respawn();
          }
        }
      }
    }

    // Pickup collision
    for (const p of pickups) {
      if (!p.active) continue;
      if (dist(this, p) < p.radius + 10) {
        if (p.type === 'wrench') {
          this.wrenches++;
          p.active = false;
        }
      }
    }

    // Car collision
    for (const other of cars) {
      if (other === this) continue;
      const d = dist(this, other);
      if (d < 18 && d > 0) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const pushForce = (18 - d) * 0.3;
        this.x += (dx / d) * pushForce;
        this.y += (dy / d) * pushForce;
        other.x -= (dx / d) * pushForce * 0.5;
        other.y -= (dy / d) * pushForce * 0.5;
        this.speed *= 0.9;
      }
    }
  }

  applyZoneEffect(zone) {
    switch (zone) {
      case 'wall':
        // Bounce back - reverse movement and reduce speed
        this.x = this.prevX;
        this.y = this.prevY;
        this.speed *= -0.3;
        break;
      case 'hazard':
        // Slow down and take damage over time
        this.speed *= 0.96;
        if (Math.random() < 0.02) {
          this.health -= 1;
          if (this.health <= 0) this.respawn();
        }
        break;
      case 'boost':
        // Speed boost
        this.speed = Math.min(this.speed + 0.15, this.maxSpeed * 1.4);
        break;
      case 'pit':
        // Heal and slow slightly
        this.health = Math.min(100, this.health + 0.3);
        this.speed *= 0.99;
        break;
      case 'track':
        // Normal surface - no special effect
        break;
      default:
        // Off-track (0 or empty) - heavy friction
        this.speed *= this.offTrackFriction;
        break;
    }
  }

  respawn() {
    this.respawnTimer = 120;
    this.health = 0;
    // Respawn at nearest waypoint
    if (trackState.waypoints.length > 0) {
      let minD = Infinity;
      let minWP = trackState.waypoints[0];
      for (const wp of trackState.waypoints) {
        const d = dist(this, wp);
        if (d < minD) { minD = d; minWP = wp; }
      }
      this.x = minWP.x;
      this.y = minWP.y;
    }
  }

  checkFinishLine() {
    if (!trackState.finishLine) return;
    const fl = trackState.finishLine;

    // Check if car path crosses the finish line
    const crossed = linesIntersect(
      this.prevX, this.prevY, this.x, this.y,
      fl.x1, fl.y1, fl.x2, fl.y2
    );

    if (crossed) {
      const dir = getCrossingDirection(this.prevX, this.prevY, this.x, this.y, fl);
      if (dir > 0) {
        // Forward crossing
        this.lap++;
        if (this.lap >= trackState.laps && !this.finished) {
          this.finished = true;
          this.finishTime = raceTime;
        }
      } else if (dir < 0 && this.lap > 0) {
        // Backward crossing
        this.lap--;
      }
    }

    // Update total progress for position tracking
    this.updateProgress();
  }

  updateProgress() {
    // Progress = completed laps + fractional progress based on nearest waypoint
    if (trackState.waypoints.length === 0) {
      this.totalProgress = this.lap;
      return;
    }
    let minD = Infinity;
    let minI = 0;
    for (let i = 0; i < trackState.waypoints.length; i++) {
      const d = dist(this, trackState.waypoints[i]);
      if (d < minD) { minD = d; minI = i; }
    }
    this.waypointProgress = minI;
    this.totalProgress = this.lap * trackState.waypoints.length + minI;
  }

  updatePlayer(keys, dt, bullets, cars) {
    if (keys['ArrowUp'] || keys['w']) {
      this.speed += this.acceleration;
    }
    if (keys['ArrowDown'] || keys['s']) {
      this.speed -= this.braking;
    }
    if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
    if (this.speed < -this.maxSpeed * 0.3) this.speed = -this.maxSpeed * 0.3;

    const turnFactor = Math.min(Math.abs(this.speed) / 2, 1);
    if (keys['ArrowLeft'] || keys['a']) {
      this.angle -= this.turnSpeed * turnFactor;
    }
    if (keys['ArrowRight'] || keys['d']) {
      this.angle += this.turnSpeed * turnFactor;
    }

    // Shoot cannon
    if (keys[' '] && this.cooldown <= 0 && this.ammo > 0) {
      this.shootCannon(bullets);
      keys[' '] = false;
    }

    // Shoot missile
    if (keys['m'] && this.missileCooldown <= 0 && this.missiles > 0) {
      this.shootMissile(bullets, cars);
      keys['m'] = false;
    }

    // Nitro
    if (keys['n'] && this.nitro > 0 && !this.nitroActive) {
      this.nitroActive = true;
      this.nitroTimer = 30;
      this.nitro--;
      keys['n'] = false;
    }
  }

  updateAI(dt, cars, bullets) {
    if (trackState.waypoints.length === 0) return;

    // Follow waypoints
    const target = trackState.waypoints[this.aiTargetIndex];
    const distToTarget = dist(this, target);

    // Advance to next waypoint when close enough
    if (distToTarget < 40) {
      this.aiTargetIndex = (this.aiTargetIndex + 1) % trackState.waypoints.length;
    }

    // Look ahead a few waypoints for smoother steering
    const lookAheadIdx = (this.aiTargetIndex + 2) % trackState.waypoints.length;
    const lookAheadTarget = trackState.waypoints[lookAheadIdx];

    // Blend between current and look-ahead target
    const steerTarget = {
      x: lerp(target.x, lookAheadTarget.x, 0.3),
      y: lerp(target.y, lookAheadTarget.y, 0.3)
    };

    const targetAngle = angleBetween(this, steerTarget);
    let angleDiff = normalizeAngle(targetAngle - this.angle);

    // Steering noise for variety
    this.aiSteerNoise += (Math.random() - 0.5) * 0.005;
    this.aiSteerNoise *= 0.98;

    const steer = Math.max(-this.turnSpeed, Math.min(this.turnSpeed,
      angleDiff * 0.15 * this.aiPersonality.accuracy + this.aiSteerNoise));
    this.angle += steer;

    // Accelerate
    if (Math.abs(angleDiff) < 0.8) {
      this.speed += this.acceleration * 0.9;
    } else {
      this.speed += this.acceleration * 0.4;
    }
    if (this.speed > this.maxSpeed * 0.92) this.speed = this.maxSpeed * 0.92;

    // AI shooting - shoot at nearby cars ahead
    if (this.cooldown <= 0 && this.ammo > 0 && Math.random() < 0.02 * this.aiPersonality.aggression) {
      for (const other of cars) {
        if (other === this) continue;
        const d = dist(this, other);
        if (d < 150) {
          const aToOther = angleBetween(this, other);
          let aDiff = normalizeAngle(aToOther - this.angle);
          if (Math.abs(aDiff) < 0.5) {
            this.shootCannon(bullets);
            break;
          }
        }
      }
    }

    // AI missile usage
    if (this.missileCooldown <= 0 && this.missiles > 0 && Math.random() < 0.005 * this.aiPersonality.aggression) {
      this.shootMissile(bullets, cars);
    }

    // AI nitro occasionally
    if (this.nitro > 0 && !this.nitroActive && Math.random() < this.aiPersonality.nitroFreq) {
      this.nitroActive = true;
      this.nitroTimer = 30;
      this.nitro--;
    }
  }

  shootCannon(bullets) {
    if (this.cooldown > 0 || this.ammo <= 0) return;
    bullets.push({
      x: this.x + Math.cos(this.angle) * 15,
      y: this.y + Math.sin(this.angle) * 15,
      vx: Math.cos(this.angle) * 6 + this.speed * Math.cos(this.angle) * 0.3,
      vy: Math.sin(this.angle) * 6 + this.speed * Math.sin(this.angle) * 0.3,
      owner: this,
      life: 60,
      isMissile: false,
      target: null
    });
    this.ammo--;
    this.cooldown = 12;
  }

  shootMissile(bullets, cars) {
    if (this.missileCooldown > 0 || this.missiles <= 0) return;

    // Find nearest opponent to target
    let nearestCar = null;
    let nearestDist = Infinity;
    for (const other of cars) {
      if (other === this) continue;
      const d = dist(this, other);
      if (d < nearestDist && d < 400) {
        nearestDist = d;
        nearestCar = other;
      }
    }

    bullets.push({
      x: this.x + Math.cos(this.angle) * 15,
      y: this.y + Math.sin(this.angle) * 15,
      vx: Math.cos(this.angle) * 4,
      vy: Math.sin(this.angle) * 4,
      owner: this,
      life: 180, // Missiles last longer
      isMissile: true,
      target: nearestCar, // Homing target
      turnRate: 0.06
    });
    this.missiles--;
    this.missileCooldown = 60;
  }

  draw(ctx) {
    // Draw dust
    for (const p of this.dustParticles) {
      const alpha = p.life / p.maxLife * 0.4;
      ctx.fillStyle = `rgba(160,140,100,${alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }

    if (this.respawnTimer > 0) {
      if (Math.floor(this.respawnTimer / 5) % 2 === 0) return;
    }

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    // Car shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width, this.height);

    // Car body
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

    // Windshield
    ctx.fillStyle = '#1a1a2a';
    ctx.fillRect(2, -this.height / 2 + 2, 5, this.height - 4);

    // Cannon
    ctx.fillStyle = '#444';
    ctx.fillRect(this.width / 2 - 2, -2, 6, 4);

    // Missile launcher indicator
    if (this.missiles > 0) {
      ctx.fillStyle = '#a00';
      ctx.fillRect(this.width / 2 - 2, -5, 4, 2);
      ctx.fillRect(this.width / 2 - 2, 3, 4, 2);
    }

    // Nitro flame
    if (this.nitroActive) {
      ctx.fillStyle = `rgba(255,${100 + Math.random() * 155},0,0.8)`;
      ctx.fillRect(-this.width / 2 - 8 - Math.random() * 5, -3, 8 + Math.random() * 4, 6);
    }

    // Stun indicator
    if (this.stunTimer > 0) {
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = 12 + Math.random() * 5;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        ctx.lineTo(Math.cos(a + 0.3) * (r + 4), Math.sin(a + 0.3) * (r + 4));
        ctx.stroke();
      }
    }

    ctx.restore();

    // Health bar
    if (this.health < 100) {
      const barW = 20;
      const barH = 3;
      ctx.fillStyle = '#300';
      ctx.fillRect(this.x - barW / 2, this.y - 14, barW, barH);
      ctx.fillStyle = this.health > 50 ? '#0a0' : (this.health > 25 ? '#aa0' : '#a00');
      ctx.fillRect(this.x - barW / 2, this.y - 14, barW * (this.health / 100), barH);
    }
  }
}

// ========================================
// EXPLOSIONS
// ========================================

let explosions = [];

function createExplosion(x, y) {
  const particles = [];
  for (let i = 0; i < 20; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    particles.push({
      x: x, y: y,
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd,
      life: 20 + Math.random() * 20,
      maxLife: 40,
      size: 2 + Math.random() * 4,
      color: Math.random() < 0.5 ? '#ff6600' : '#ffcc00'
    });
  }
  return { particles };
}

// ========================================
// BULLETS & MISSILES
// ========================================

let bullets = [];

function updateBullets(cars) {
  bullets = bullets.filter(b => {
    // Missile homing behavior
    if (b.isMissile && b.target && b.target.health > 0 && b.target.respawnTimer <= 0) {
      const targetAngle = angleBetween(b, b.target);
      const currentAngle = Math.atan2(b.vy, b.vx);
      let angleDiff = normalizeAngle(targetAngle - currentAngle);
      const turn = Math.max(-b.turnRate, Math.min(b.turnRate, angleDiff));
      const newAngle = currentAngle + turn;
      const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
      b.vx = Math.cos(newAngle) * speed;
      b.vy = Math.sin(newAngle) * speed;
      // Missiles accelerate slightly
      b.vx *= 1.005;
      b.vy *= 1.005;
    }

    b.x += b.vx;
    b.y += b.vy;
    b.life--;

    // Check wall collision
    if (getZoneAt(b.x, b.y) === 'wall') {
      explosions.push(createExplosion(b.x, b.y));
      return false;
    }

    // Check car hits
    for (const car of cars) {
      if (car === b.owner) continue;
      if (dist(b, car) < 14) {
        const damage = b.isMissile ? 35 : 15;
        car.health -= damage;
        car.stunTimer = b.isMissile ? 30 : 15;
        car.speed *= b.isMissile ? 0.2 : 0.5;
        explosions.push(createExplosion(b.x, b.y));
        if (car.health <= 0) {
          car.respawn();
        }
        return false;
      }
    }

    // Out of bounds
    if (b.x < 0 || b.x > W || b.y < 0 || b.y > H) return false;

    return b.life > 0;
  });
}

function drawBullets() {
  for (const b of bullets) {
    if (b.isMissile) {
      // Missile: red triangle shape
      const angle = Math.atan2(b.vy, b.vx);
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(angle);
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.moveTo(5, 0);
      ctx.lineTo(-4, -3);
      ctx.lineTo(-4, 3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Missile trail
      ctx.strokeStyle = 'rgba(255,100,0,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx * 4, b.y - b.vy * 4);
      ctx.stroke();
      // Smoke puffs
      if (Math.random() < 0.5) {
        ctx.fillStyle = 'rgba(150,150,150,0.3)';
        ctx.beginPath();
        ctx.arc(b.x - b.vx * 3 + (Math.random() - 0.5) * 4,
                b.y - b.vy * 3 + (Math.random() - 0.5) * 4,
                2 + Math.random() * 2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else {
      // Cannon bullet: yellow dot
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
      ctx.fill();
      // Trail
      ctx.strokeStyle = 'rgba(255,255,0,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx * 3, b.y - b.vy * 3);
      ctx.stroke();
    }
  }
}

// ========================================
// TRACK RENDERING
// ========================================

// Zone rendering colors (more opaque for default, semi-transparent for custom)
const ZONE_RENDER_COLORS = {
  track:  { default: '#4a3a2a', overlay: 'rgba(0,180,0,0.15)' },
  wall:   { default: '#2a1a0a', overlay: 'rgba(180,0,0,0.25)' },
  hazard: { default: '#5a5a10', overlay: 'rgba(180,180,0,0.3)' },
  boost:  { default: '#2a3a5a', overlay: 'rgba(0,150,255,0.25)' },
  pit:    { default: '#3a2a4a', overlay: 'rgba(150,0,180,0.25)' },
};

function drawTrack() {
  const ts = trackState;

  if (ts.isCustom) {
    // Custom track: draw background image + zone overlay
    drawCustomTrack();
  } else {
    // Default track: draw with built-in styling
    drawDefaultTrack();
  }

  // Draw finish line
  if (ts.finishLine) {
    const fl = ts.finishLine;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(fl.x1, fl.y1);
    ctx.lineTo(fl.x2, fl.y2);
    ctx.stroke();

    // Checkerboard
    const dx = fl.x2 - fl.x1;
    const dy = fl.y2 - fl.y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const steps = Math.floor(len / 8);
    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const px = fl.x1 + dx * t;
      const py = fl.y1 + dy * t;
      ctx.fillStyle = i % 2 === 0 ? '#eee' : '#222';
      ctx.fillRect(px - 3, py - 3, 6, 6);
    }
  }
}

function drawDefaultTrack() {
  const ts = trackState;

  // Ground
  ctx.fillStyle = groundColor;
  ctx.fillRect(0, 0, W, H);

  // Ground texture
  ctx.fillStyle = '#222218';
  for (let i = 0; i < 80; i++) {
    const rx = (i * 137.5 + 50) % W;
    const ry = (i * 89.3 + 30) % H;
    ctx.fillRect(rx, ry, 2 + (i % 3), 2 + (i % 2));
  }

  // Draw zones from grid
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      if (zone && ZONE_RENDER_COLORS[zone]) {
        ctx.fillStyle = ZONE_RENDER_COLORS[zone].default;
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      }
    }
  }

  // Draw special zone indicators
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      const cx = c * ts.cellW + ts.cellW / 2;
      const cy = r * ts.cellH + ts.cellH / 2;

      if (zone === 'hazard') {
        // Yellow warning stripes
        ctx.fillStyle = 'rgba(200,180,0,0.3)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      } else if (zone === 'boost') {
        // Blue arrows
        ctx.fillStyle = 'rgba(0,120,255,0.2)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
        // Arrow symbol
        if ((r + c) % 3 === 0) {
          ctx.fillStyle = 'rgba(100,200,255,0.4)';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('>', cx, cy + 3);
          ctx.textAlign = 'left';
        }
      } else if (zone === 'pit') {
        // Purple cross
        ctx.fillStyle = 'rgba(180,50,220,0.2)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
        if ((r + c) % 3 === 0) {
          ctx.fillStyle = 'rgba(200,100,255,0.5)';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('+', cx, cy + 3);
          ctx.textAlign = 'left';
        }
      }
    }
  }

  // Track border effect - draw wall outlines
  ctx.strokeStyle = trackBorderColor;
  ctx.lineWidth = 1;
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      if (ts.grid.data[r][c] === 'wall') {
        // Only draw border on edges adjacent to track
        const x = c * ts.cellW;
        const y = r * ts.cellH;
        if (c > 0 && ts.grid.data[r][c - 1] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + ts.cellH); ctx.stroke();
        }
        if (c < ts.grid.cols - 1 && ts.grid.data[r][c + 1] === 'track') {
          ctx.beginPath(); ctx.moveTo(x + ts.cellW, y); ctx.lineTo(x + ts.cellW, y + ts.cellH); ctx.stroke();
        }
        if (r > 0 && ts.grid.data[r - 1][c] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + ts.cellW, y); ctx.stroke();
        }
        if (r < ts.grid.rows - 1 && ts.grid.data[r + 1][c] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y + ts.cellH); ctx.lineTo(x + ts.cellW, y + ts.cellH); ctx.stroke();
        }
      }
    }
  }

  // Environment decorations
  drawEnvironment();
}

function drawCustomTrack() {
  const ts = trackState;

  // Background image or dark ground
  if (ts.bgImage) {
    ctx.drawImage(ts.bgImage, 0, 0, W, H);
  } else {
    ctx.fillStyle = '#1a1a12';
    ctx.fillRect(0, 0, W, H);
  }

  // Semi-transparent zone overlay
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      if (zone && ZONE_RENDER_COLORS[zone]) {
        ctx.fillStyle = ZONE_RENDER_COLORS[zone].overlay;
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      }
    }
  }
}

function drawEnvironment() {
  // Rusty barrels (positioned in off-track areas)
  const barrels = [
    {x: 450, y: 300}, {x: 460, y: 310}, {x: 455, y: 320},
    {x: 300, y: 200}, {x: 650, y: 400},
    {x: 500, y: 150}, {x: 180, y: 450}
  ];
  for (const b of barrels) {
    if (getZoneAt(b.x, b.y) !== 'track') {
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#432';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = '#543210';
      ctx.fillRect(b.x - 4, b.y - 1, 8, 2);
    }
  }

  // Wrecked cars
  const wrecks = [
    {x: 430, y: 280, a: 0.5}, {x: 550, y: 350, a: 1.2}, {x: 250, y: 380, a: 2.1}
  ];
  for (const w of wrecks) {
    if (getZoneAt(w.x, w.y) !== 'track') {
      ctx.save();
      ctx.translate(w.x, w.y);
      ctx.rotate(w.a);
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(-12, -7, 24, 14);
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(-8, -5, 16, 10);
      ctx.restore();
    }
  }

  // Warning signs
  ctx.fillStyle = '#aa0';
  ctx.font = 'bold 10px monospace';
  ctx.fillText('DANGER', 420, 270);
  ctx.fillText('NO EXIT', 530, 340);

  // Pipes along edges
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(50, 650); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(850, 50); ctx.lineTo(850, 650); ctx.stroke();

  // Tower structures
  drawTower(60, 60);
  drawTower(840, 60);
  drawTower(60, 640);
  drawTower(840, 640);
}

function drawTower(x, y) {
  ctx.fillStyle = '#444';
  ctx.fillRect(x - 8, y - 8, 16, 16);
  ctx.fillStyle = '#333';
  ctx.fillRect(x - 5, y - 20, 10, 12);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x, y - 20);
  ctx.lineTo(x, y - 30);
  ctx.stroke();
  if (Math.floor(Date.now() / 500) % 2 === 0) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.arc(x, y - 30, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ========================================
// DRAW OBSTACLES & PICKUPS
// ========================================

function drawObstacles() {
  for (const obs of obstacles) {
    if (!obs.active) continue;
    if (obs.type === 'mine') {
      ctx.fillStyle = '#660000';
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 1;
      ctx.stroke();
      if (Math.floor(Date.now() / 300) % 2 === 0) {
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(obs.x, obs.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  for (const p of pickups) {
    if (!p.active) continue;
    if (p.type === 'wrench') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Date.now() / 500);
      ctx.fillStyle = '#ccc';
      ctx.fillRect(-3, -8, 6, 16);
      ctx.fillRect(-8, -3, 16, 6);
      ctx.restore();
      ctx.fillStyle = 'rgba(200,200,255,0.15)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ========================================
// DRAW EXPLOSIONS
// ========================================

function drawExplosions() {
  explosions = explosions.filter(e => {
    let alive = false;
    for (const p of e.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      p.life--;
      if (p.life > 0) {
        alive = true;
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
    return alive;
  });
}

// ========================================
// HUD
// ========================================

function drawHUD(player, cars) {
  const sorted = [...cars].sort((a, b) => b.totalProgress - a.totalProgress);
  const playerPos = sorted.indexOf(player) + 1;

  // Bottom HUD bar
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, H - 50, W, 50);

  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 14px monospace';

  // Position
  ctx.fillText(`POS: ${playerPos}/${cars.length}`, 20, H - 30);

  // Lap
  ctx.fillText(`LAP: ${Math.min(player.lap + 1, trackState.laps)}/${trackState.laps}`, 160, H - 30);

  // Speed bar
  ctx.fillStyle = '#333';
  ctx.fillRect(280, H - 38, 80, 14);
  const speedPct = Math.abs(player.speed) / player.maxSpeed;
  ctx.fillStyle = player.nitroActive ? '#00aaff' : '#ff6600';
  ctx.fillRect(280, H - 38, 80 * speedPct, 14);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.fillText('SPEED', 300, H - 28);

  // Ammo
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 14px monospace';
  ctx.fillText(`AMMO:${player.ammo}`, 380, H - 30);

  // Missiles
  ctx.fillStyle = '#ff3333';
  ctx.fillText(`MSL:${player.missiles}`, 470, H - 30);

  // Health bar
  ctx.fillStyle = '#333';
  ctx.fillRect(550, H - 38, 80, 14);
  ctx.fillStyle = player.health > 50 ? '#00aa00' : (player.health > 25 ? '#aaaa00' : '#aa0000');
  ctx.fillRect(550, H - 38, 80 * (player.health / 100), 14);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.fillText('HEALTH', 568, H - 28);

  // Nitro
  ctx.fillStyle = '#00aaff';
  ctx.font = 'bold 14px monospace';
  ctx.fillText(`NIT:${player.nitro}`, 650, H - 30);

  // Wrenches
  ctx.fillStyle = '#ccc';
  ctx.fillText(`WRENCHES:${player.wrenches}`, 720, H - 30);

  // Race time
  const secs = Math.floor(raceTime / 60);
  const mins = Math.floor(secs / 60);
  const displaySecs = secs % 60;
  ctx.fillStyle = '#ff6600';
  ctx.fillText(`${mins}:${displaySecs.toString().padStart(2, '0')}`, 860, H - 30);

  // Zone indicator
  const currentZone = getZoneAt(player.x, player.y);
  if (currentZone && currentZone !== 'track') {
    let zoneText = '';
    let zoneColor = '#fff';
    switch (currentZone) {
      case 'boost': zoneText = 'BOOST!'; zoneColor = '#00aaff'; break;
      case 'hazard': zoneText = 'HAZARD!'; zoneColor = '#ffaa00'; break;
      case 'pit': zoneText = 'PIT STOP'; zoneColor = '#aa55ff'; break;
      case 'wall': zoneText = 'WALL'; zoneColor = '#ff3333'; break;
    }
    if (zoneText) {
      ctx.fillStyle = zoneColor;
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(zoneText, W / 2, H - 60);
      ctx.textAlign = 'left';
    }
  }

  // Top position bar
  ctx.fillStyle = '#222';
  ctx.fillRect(0, 0, W, 24);
  for (let i = 0; i < sorted.length; i++) {
    const c = sorted[i];
    ctx.fillStyle = c.color;
    ctx.font = 'bold 12px monospace';
    ctx.fillText(`${i + 1}. ${c.name}  LAP ${Math.min(c.lap + 1, trackState.laps)}`, 20 + i * 230, 16);
  }
}

// ========================================
// MENU SCREEN
// ========================================

function drawMenu() {
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);

  // Animated background lines
  const t = Date.now() / 1000;
  ctx.strokeStyle = 'rgba(255,100,0,0.05)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 20; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * 35 + Math.sin(t + i) * 10);
    ctx.lineTo(W, i * 35 + Math.cos(t + i) * 10);
    ctx.stroke();
  }

  // Title
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 56px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('WASTELAND', W / 2, 160);
  ctx.fillStyle = '#cc4400';
  ctx.font = 'bold 72px monospace';
  ctx.fillText('RACERS', W / 2, 230);

  // Subtitle
  ctx.fillStyle = '#886644';
  ctx.font = '16px monospace';
  ctx.fillText('POST-APOCALYPTIC COMBAT RACING', W / 2, 270);

  // Track name
  ctx.fillStyle = '#aa8866';
  ctx.font = 'bold 18px monospace';
  ctx.fillText(`TRACK: ${trackState.name}`, W / 2, 330);

  // Controls
  ctx.fillStyle = '#aa8866';
  ctx.font = '14px monospace';
  ctx.fillText('ARROW KEYS or WASD - STEER & ACCELERATE', W / 2, 390);
  ctx.fillText('SPACE - SHOOT CANNON', W / 2, 415);
  ctx.fillText('M - FIRE MISSILE', W / 2, 440);
  ctx.fillText('N - NITRO BOOST', W / 2, 465);

  // Start prompt
  ctx.fillStyle = Math.floor(Date.now() / 500) % 2 === 0 ? '#ff6600' : '#cc4400';
  ctx.font = 'bold 24px monospace';
  ctx.fillText('PRESS ENTER TO RACE', W / 2, 530);

  // Load track prompt
  ctx.fillStyle = '#668844';
  ctx.font = '16px monospace';
  ctx.fillText('PRESS L TO LOAD CUSTOM TRACK', W / 2, 580);

  // Version info
  ctx.fillStyle = '#444';
  ctx.font = '11px monospace';
  ctx.fillText('v2.0 - Zone System + Track Loading + Missiles', W / 2, 660);

  ctx.textAlign = 'left';
}

// ========================================
// COUNTDOWN
// ========================================

function drawCountdown() {
  const count = Math.ceil(countdownTimer / 60);
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(W / 2 - 60, H / 2 - 50, 120, 100);
  ctx.fillStyle = count > 0 ? '#ff6600' : '#00ff00';
  ctx.font = 'bold 64px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(count > 0 ? count.toString() : 'GO!', W / 2, H / 2 + 20);
  ctx.textAlign = 'left';
}

// ========================================
// RESULTS SCREEN
// ========================================

function drawResults(cars) {
  ctx.fillStyle = 'rgba(0,0,0,0.8)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 48px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RACE COMPLETE', W / 2, 120);

  const sorted = [...cars].sort((a, b) => {
    if (a.finished && b.finished) return a.finishTime - b.finishTime;
    if (a.finished) return -1;
    if (b.finished) return 1;
    return b.totalProgress - a.totalProgress;
  });

  ctx.font = 'bold 24px monospace';
  for (let i = 0; i < sorted.length; i++) {
    const c = sorted[i];
    ctx.fillStyle = c.color;
    const timeStr = c.finished
      ? `${Math.floor(c.finishTime / 3600)}:${(Math.floor(c.finishTime / 60) % 60).toString().padStart(2, '0')}`
      : 'DNF';
    ctx.fillText(`${i + 1}. ${c.name}  ${timeStr}`, W / 2, 200 + i * 50);
  }

  // Award wrenches based on finishing position
  const playerIdx = sorted.indexOf(player);
  const wrenchAward = [3, 2, 1, 0][playerIdx] || 0;

  ctx.fillStyle = '#ccc';
  ctx.font = '18px monospace';
  ctx.fillText(`+${wrenchAward} WRENCHES EARNED`, W / 2, 430);

  ctx.fillStyle = '#886644';
  ctx.font = '18px monospace';
  ctx.fillText('PRESS ENTER TO CONTINUE TO SHOP', W / 2, 500);
  ctx.fillText('PRESS R TO RACE AGAIN', W / 2, 540);

  ctx.textAlign = 'left';
}

// ========================================
// SHOP SCREEN
// ========================================

function drawShop(player) {
  ctx.fillStyle = 'rgba(10,10,8,0.95)';
  ctx.fillRect(0, 0, W, H);

  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 40px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('UPGRADE SHOP', W / 2, 80);

  ctx.fillStyle = '#ccc';
  ctx.font = '16px monospace';
  ctx.fillText(`WRENCHES: ${player.wrenches}`, W / 2, 120);

  const upgrades = [
    { name: 'SPEED', key: '1', cost: 1, current: player.speedUpgrade, max: 5 },
    { name: 'ACCELERATION', key: '2', cost: 1, current: player.accelUpgrade, max: 5 },
    { name: 'TIRES', key: '3', cost: 1, current: player.tireUpgrade, max: 5 },
    { name: 'AMMO (+5)', key: '4', cost: 1, current: 0, max: 99 },
    { name: 'NITRO (+1)', key: '5', cost: 2, current: 0, max: 99 },
    { name: 'MISSILE (+1)', key: '6', cost: 3, current: 0, max: 99 },
  ];

  ctx.textAlign = 'left';
  for (let i = 0; i < upgrades.length; i++) {
    const u = upgrades[i];
    const y = 180 + i * 60;
    ctx.fillStyle = '#886644';
    ctx.font = '14px monospace';
    ctx.fillText(`[${u.key}]`, 200, y);
    ctx.fillStyle = '#ff6600';
    ctx.font = 'bold 18px monospace';
    ctx.fillText(u.name, 240, y);
    ctx.fillStyle = '#888';
    ctx.font = '14px monospace';
    ctx.fillText(`Cost: ${u.cost} wrench${u.cost > 1 ? 'es' : ''}`, 500, y);

    if (u.max <= 5) {
      for (let j = 0; j < u.max; j++) {
        ctx.fillStyle = j < u.current ? '#ff6600' : '#333';
        ctx.fillRect(500 + j * 20, y + 8, 15, 10);
      }
    }
  }

  ctx.fillStyle = '#886644';
  ctx.font = '18px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('PRESS ENTER TO RACE', W / 2, 580);
  ctx.textAlign = 'left';
}

// ========================================
// INITIALIZE GAME
// ========================================

const player = new Car('#cc3300', 'PLAYER', true);
const ai1 = new Car('#3366cc', 'VIPER', false);
const ai2 = new Car('#33aa33', 'SKULL', false);
const ai3 = new Car('#aa33aa', 'GRIM', false);
const cars = [player, ai1, ai2, ai3];

// Generate default track on startup
generateDefaultTrack();

let resultsWrenchesAwarded = false;

function resetRace() {
  for (let i = 0; i < cars.length; i++) {
    cars[i].reset(i);
  }
  bullets = [];
  explosions = [];
  raceTime = 0;
  resultsWrenchesAwarded = false;
  generateObstacles();
}

// ========================================
// INPUT HANDLING
// ========================================

const keys = {};
document.addEventListener('keydown', e => {
  keys[e.key] = true;

  if (gameState === STATE.MENU) {
    if (e.key === 'Enter') {
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    }
    if (e.key === 'l' || e.key === 'L') {
      document.getElementById('track-file-input').click();
    }
  }

  if (gameState === STATE.RESULTS) {
    if (e.key === 'Enter') {
      // Award wrenches before going to shop
      if (!resultsWrenchesAwarded) {
        const sorted = [...cars].sort((a, b) => {
          if (a.finished && b.finished) return a.finishTime - b.finishTime;
          if (a.finished) return -1;
          if (b.finished) return 1;
          return b.totalProgress - a.totalProgress;
        });
        const playerIdx = sorted.indexOf(player);
        const wrenchAward = [3, 2, 1, 0][playerIdx] || 0;
        player.wrenches += wrenchAward;
        resultsWrenchesAwarded = true;
      }
      gameState = STATE.SHOP;
    } else if (e.key === 'r' || e.key === 'R') {
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    }
  }

  if (gameState === STATE.SHOP) {
    if (e.key === 'Enter') {
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    }
    if (e.key === '1' && player.wrenches >= 1 && player.speedUpgrade < 5) {
      player.speedUpgrade++;
      player.wrenches--;
    }
    if (e.key === '2' && player.wrenches >= 1 && player.accelUpgrade < 5) {
      player.accelUpgrade++;
      player.wrenches--;
    }
    if (e.key === '3' && player.wrenches >= 1 && player.tireUpgrade < 5) {
      player.tireUpgrade++;
      player.wrenches--;
    }
    if (e.key === '4' && player.wrenches >= 1) {
      player.ammo += 5;
      player.wrenches--;
    }
    if (e.key === '5' && player.wrenches >= 2) {
      player.nitro++;
      player.wrenches -= 2;
    }
    if (e.key === '6' && player.wrenches >= 3) {
      player.missiles++;
      player.wrenches -= 3;
    }
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

// ========================================
// MAIN GAME LOOP
// ========================================

function gameLoop() {
  ctx.clearRect(0, 0, W, H);

  switch (gameState) {
    case STATE.MENU:
      drawMenu();
      break;

    case STATE.COUNTDOWN:
      drawTrack();
      drawObstacles();
      for (const c of cars) c.draw(ctx);
      drawHUD(player, cars);
      drawCountdown();
      countdownTimer--;
      if (countdownTimer <= -60) {
        gameState = STATE.RACING;
      }
      break;

    case STATE.RACING:
      raceTime++;

      // Update
      for (const c of cars) {
        c.update(keys, 1, cars, bullets);
      }
      updateBullets(cars);

      // Check race end
      const allFinishedOrTimeout = cars.every(c => c.finished) || raceTime > 60 * 60 * 5;
      if (player.finished || allFinishedOrTimeout) {
        if (!player._resultDelay) player._resultDelay = 120;
        player._resultDelay--;
        if (player._resultDelay <= 0) {
          gameState = STATE.RESULTS;
          player._resultDelay = 0;
        }
      }

      // Draw
      drawTrack();
      drawObstacles();
      drawBullets();
      for (const c of cars) c.draw(ctx);
      drawExplosions();
      drawHUD(player, cars);
      break;

    case STATE.RESULTS:
      drawResults(cars);
      break;

    case STATE.SHOP:
      drawShop(player);
      break;
  }

  requestAnimationFrame(gameLoop);
}

// Start
gameLoop();
</script>
</body>
</html>
