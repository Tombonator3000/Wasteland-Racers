<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WASTELAND RACERS</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a0a0a;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    overflow: hidden;
    font-family: monospace;
  }
  canvas {
    image-rendering: pixelated;
    border: 2px solid #333;
    max-width: 100vw;
    max-height: 100vh;
    object-fit: contain;
  }
  #ui-overlay {
    position: absolute;
    top: 10px; left: 50%;
    transform: translateX(-50%);
    color: #ff6600;
    font-family: monospace;
    font-size: 14px;
    text-align: center;
    pointer-events: none;
    text-shadow: 0 0 6px rgba(255,100,0,0.5);
  }
  /* Hidden file input for track loading */
  #track-file-input {
    position: absolute;
    top: -9999px;
    left: -9999px;
  }
</style>
</head>
<body>
<canvas id="game"></canvas>
<input type="file" id="track-file-input" accept=".json">
<script>
// ========================================
// WASTELAND RACERS - Core Engine v2
// Inspired by Badlands (1990) & Super Off Road
// Now with JSON track loading & zone system
// ========================================

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// --- Canvas sizing ---
const W = 900;
const H = 700;
canvas.width = W;
canvas.height = H;

// --- Game State ---
const STATE = {
  MENU: 0,
  COUNTDOWN: 1,
  RACING: 2,
  RESULTS: 3,
  SHOP: 4,
  TRACK_SELECT: 5,
  HIGHSCORES: 6
};
let gameState = STATE.MENU;
let countdownTimer = 0;
let raceTime = 0;
let menuSelection = 0; // 0=Race, 1=Highscores

// --- Progression System ---
let progression = {
  currentTrackIndex: 0,
  unlockedTracks: 1,
  totalWrenches: 0,
  money: 0,
  highscores: {} // trackName: { bestTime, bestPosition, bestLap }
};

function saveProgress() {
  try {
    const data = {
      unlockedTracks: progression.unlockedTracks,
      totalWrenches: progression.totalWrenches,
      money: progression.money,
      highscores: progression.highscores,
      playerUpgrades: {
        speed: player ? player.speedUpgrade : 0,
        accel: player ? player.accelUpgrade : 0,
        tires: player ? player.tireUpgrade : 0,
        wrenches: player ? player.wrenches : 0
      }
    };
    localStorage.setItem('wasteland-racers-save', JSON.stringify(data));
  } catch (e) { /* localStorage not available */ }
}

function loadProgress() {
  try {
    const raw = localStorage.getItem('wasteland-racers-save');
    if (!raw) return;
    const data = JSON.parse(raw);
    progression.unlockedTracks = data.unlockedTracks || 1;
    progression.totalWrenches = data.totalWrenches || 0;
    progression.money = data.money || 0;
    progression.highscores = data.highscores || {};
    if (data.playerUpgrades) {
      pendingUpgrades = data.playerUpgrades;
    }
  } catch (e) { /* localStorage not available */ }
}

let pendingUpgrades = null; // loaded from save, applied after player is created

// --- Track Definitions ---
// Each track is defined by its spline points, name, laps, and special zones
const TRACK_DEFS = [
  {
    name: 'Wasteland Circuit',
    difficulty: 'EASY',
    laps: 3,
    description: 'A classic oval through the wasteland',
    reward: [4, 3, 2, 1],
    points: [
      {x: 200, y: 120}, {x: 380, y: 80}, {x: 580, y: 80}, {x: 720, y: 120},
      {x: 790, y: 200}, {x: 810, y: 320}, {x: 780, y: 440}, {x: 700, y: 520},
      {x: 580, y: 560}, {x: 460, y: 580}, {x: 340, y: 600}, {x: 200, y: 580},
      {x: 120, y: 500}, {x: 100, y: 400}, {x: 130, y: 300}, {x: 160, y: 220},
      {x: 140, y: 160}
    ],
    hazardAt: 0.4, boostAt: 0.15, pitAt: 0.7
  },
  {
    name: 'Scorched Serpent',
    difficulty: 'MEDIUM',
    laps: 3,
    description: 'Winding S-curves through burning sands',
    reward: [5, 4, 3, 1],
    points: [
      {x: 150, y: 100}, {x: 300, y: 80}, {x: 450, y: 140}, {x: 600, y: 200},
      {x: 750, y: 160}, {x: 820, y: 250}, {x: 780, y: 350}, {x: 650, y: 380},
      {x: 500, y: 340}, {x: 350, y: 400}, {x: 200, y: 450}, {x: 120, y: 520},
      {x: 200, y: 600}, {x: 380, y: 620}, {x: 550, y: 580}, {x: 700, y: 540},
      {x: 800, y: 500}, {x: 780, y: 600}, {x: 650, y: 640}, {x: 450, y: 640},
      {x: 280, y: 580}, {x: 130, y: 450}, {x: 80, y: 320}, {x: 100, y: 200}
    ],
    hazardAt: 0.25, boostAt: 0.5, pitAt: 0.75
  },
  {
    name: 'Rust Ring',
    difficulty: 'MEDIUM',
    laps: 4,
    description: 'A rusted oval with a deadly chicane',
    reward: [6, 4, 3, 1],
    points: [
      {x: 150, y: 150}, {x: 350, y: 90}, {x: 550, y: 90}, {x: 700, y: 130},
      {x: 800, y: 230}, {x: 790, y: 350}, {x: 720, y: 420},
      {x: 600, y: 380}, {x: 520, y: 340}, {x: 480, y: 400}, {x: 420, y: 450},
      {x: 340, y: 420}, {x: 280, y: 460},
      {x: 200, y: 540}, {x: 140, y: 600}, {x: 100, y: 500},
      {x: 80, y: 380}, {x: 90, y: 260}
    ],
    hazardAt: 0.35, boostAt: 0.1, pitAt: 0.6
  },
  {
    name: 'Toxic Speedway',
    difficulty: 'HARD',
    laps: 3,
    description: 'Hazard-filled track through toxic waste',
    reward: [8, 5, 3, 1],
    points: [
      {x: 200, y: 100}, {x: 450, y: 80}, {x: 700, y: 100}, {x: 800, y: 200},
      {x: 780, y: 320}, {x: 700, y: 380}, {x: 580, y: 350}, {x: 480, y: 280},
      {x: 400, y: 320}, {x: 320, y: 400}, {x: 250, y: 480}, {x: 300, y: 560},
      {x: 430, y: 600}, {x: 580, y: 580}, {x: 700, y: 520}, {x: 780, y: 580},
      {x: 730, y: 640}, {x: 550, y: 650}, {x: 350, y: 640}, {x: 180, y: 600},
      {x: 100, y: 500}, {x: 80, y: 360}, {x: 100, y: 230}
    ],
    hazardAt: 0.2, boostAt: 0.45, pitAt: 0.8,
    extraHazards: [0.55, 0.7]
  },
  {
    name: 'Thunderdome',
    difficulty: 'EXTREME',
    laps: 4,
    description: 'The ultimate challenge - survive if you can',
    reward: [10, 7, 4, 2],
    points: [
      {x: 150, y: 120}, {x: 300, y: 70}, {x: 500, y: 70}, {x: 650, y: 100},
      {x: 780, y: 170}, {x: 830, y: 280}, {x: 800, y: 380}, {x: 700, y: 420},
      {x: 600, y: 350}, {x: 500, y: 300}, {x: 400, y: 350}, {x: 350, y: 430},
      {x: 400, y: 520}, {x: 520, y: 560}, {x: 650, y: 530}, {x: 750, y: 560},
      {x: 800, y: 620}, {x: 700, y: 660}, {x: 540, y: 650}, {x: 380, y: 630},
      {x: 250, y: 580}, {x: 150, y: 500}, {x: 100, y: 400}, {x: 90, y: 280},
      {x: 100, y: 190}
    ],
    hazardAt: 0.15, boostAt: 0.4, pitAt: 0.65,
    extraHazards: [0.3, 0.55, 0.85]
  }
];

// --- Track State ---
// All track data lives here - populated by default or from JSON
let trackState = {
  name: 'Wasteland Circuit',
  laps: 3,
  grid: { cols: 60, rows: 46, data: [] },
  waypoints: [],
  startPositions: [],
  finishLine: null,
  bgImage: null,
  cellW: 15,
  cellH: 700 / 46,
  isCustom: false
};

// ========================================
// DEFAULT TRACK GENERATION
// Uses cardinal spline to create a built-in track
// ========================================

const trackColor = '#4a3a2a';
const trackBorderColor = '#2a1a0a';
const groundColor = '#1a1a12';
const trackWidth = 70;

// Default track points now stored in TRACK_DEFS[0]

function getSplinePoints(pts, tension, numPerSeg) {
  tension = tension || 0.5;
  numPerSeg = numPerSeg || 20;
  const result = [];
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const p0 = pts[(i - 1 + n) % n];
    const p1 = pts[i];
    const p2 = pts[(i + 1) % n];
    const p3 = pts[(i + 2) % n];
    for (let t = 0; t < numPerSeg; t++) {
      const s = t / numPerSeg;
      const s2 = s * s;
      const s3 = s2 * s;
      const h1 = -tension * s + 2 * tension * s2 - tension * s3;
      const h2 = 1 + (tension - 3) * s2 + (2 - tension) * s3;
      const h3 = tension * s + (3 - 2 * tension) * s2 + (tension - 2) * s3;
      const h4 = -tension * s2 + tension * s3;
      result.push({
        x: p0.x * h1 + p1.x * h2 + p2.x * h3 + p3.x * h4,
        y: p0.y * h1 + p1.y * h2 + p2.y * h3 + p3.y * h4
      });
    }
  }
  return result;
}

function getTrackNormals(pts) {
  const normals = [];
  const n = pts.length;
  for (let i = 0; i < n; i++) {
    const next = pts[(i + 1) % n];
    const dx = next.x - pts[i].x;
    const dy = next.y - pts[i].y;
    const len = Math.sqrt(dx * dx + dy * dy);
    normals.push({ x: -dy / len, y: dx / len });
  }
  return normals;
}

// Generate track from a track definition index
function generateTrackFromDef(defIndex) {
  const def = TRACK_DEFS[defIndex] || TRACK_DEFS[0];
  const smoothTrack = getSplinePoints(def.points, 0.5, 25);
  const normals = getTrackNormals(smoothTrack);
  const cols = 60;
  const rows = 46;
  const cw = W / cols;
  const ch = H / rows;
  const data = [];

  // Generate grid by checking distance to spline
  for (let r = 0; r < rows; r++) {
    data[r] = [];
    for (let c = 0; c < cols; c++) {
      const cx = c * cw + cw / 2;
      const cy = r * ch + ch / 2;
      let minDist = Infinity;
      for (let i = 0; i < smoothTrack.length; i++) {
        const dx = cx - smoothTrack[i].x;
        const dy = cy - smoothTrack[i].y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < minDist) minDist = d;
      }
      if (minDist < trackWidth * 0.95) {
        data[r][c] = 'track';
      } else if (minDist < trackWidth * 1.1) {
        data[r][c] = 'wall';
      } else {
        data[r][c] = 0;
      }
    }
  }

  // Place hazard zone
  function placeZone(fraction, type, radius) {
    const idx = Math.floor(smoothTrack.length * fraction);
    const pt = smoothTrack[idx];
    const col = Math.floor(pt.x / cw);
    const row = Math.floor(pt.y / ch);
    const r = radius || 1;
    for (let dr = -r; dr <= r; dr++) {
      for (let dc = -r; dc <= r; dc++) {
        const rr = row + dr;
        const cc = col + dc;
        if (rr >= 0 && rr < rows && cc >= 0 && cc < cols && data[rr][cc] === 'track') {
          data[rr][cc] = type;
        }
      }
    }
  }

  placeZone(def.hazardAt, 'hazard', 1);
  placeZone(def.boostAt, 'boost', 1);
  placeZone(def.pitAt, 'pit', 1);

  // Extra hazards for harder tracks
  if (def.extraHazards) {
    for (const h of def.extraHazards) {
      placeZone(h, 'hazard', 1);
    }
  }

  // Generate AI waypoints from spline (sample every Nth point)
  const wpSpacing = Math.floor(smoothTrack.length / 30);
  const waypoints = [];
  for (let i = 0; i < smoothTrack.length; i += wpSpacing) {
    waypoints.push({ x: smoothTrack[i].x, y: smoothTrack[i].y });
  }

  // Start positions
  const startPositions = [];
  for (let i = 0; i < 4; i++) {
    const idx = i * 3;
    const pt = smoothTrack[idx];
    const n = normals[idx];
    const nextPt = smoothTrack[(idx + 1) % smoothTrack.length];
    startPositions.push({
      x: pt.x + n.x * (i % 2 === 0 ? 15 : -15),
      y: pt.y + n.y * (i % 2 === 0 ? 15 : -15),
      angle: Math.atan2(nextPt.y - pt.y, nextPt.x - pt.x)
    });
  }

  // Finish line at start of track
  const startPt = smoothTrack[0];
  const startN = normals[0];
  const finishLine = {
    x1: startPt.x + startN.x * trackWidth,
    y1: startPt.y + startN.y * trackWidth,
    x2: startPt.x - startN.x * trackWidth,
    y2: startPt.y - startN.y * trackWidth,
  };

  trackState = {
    name: def.name,
    laps: def.laps,
    grid: { cols, rows, data },
    waypoints,
    startPositions,
    finishLine,
    bgImage: null,
    cellW: cw,
    cellH: ch,
    isCustom: false,
    _smoothTrack: smoothTrack,
    _normals: normals
  };
}

// Keep backward compat
function generateDefaultTrack() {
  generateTrackFromDef(0);
}

// ========================================
// TRACK JSON LOADING
// ========================================

function loadTrackFromJSON(jsonStr) {
  try {
    const data = JSON.parse(jsonStr);
    if (!data.grid || !data.waypoints || !data.startPositions) {
      alert('Invalid track file: missing required data (grid, waypoints, startPositions)');
      return false;
    }

    const cols = data.grid.cols || 60;
    const rows = data.grid.rows || 46;

    trackState = {
      name: data.name || 'Custom Track',
      laps: data.laps || 3,
      grid: {
        cols: cols,
        rows: rows,
        data: data.grid.data
      },
      waypoints: data.waypoints,
      startPositions: data.startPositions,
      finishLine: data.finishLine || null,
      bgImage: null,
      cellW: W / cols,
      cellH: H / rows,
      isCustom: true
    };

    // Load background image if present
    if (data.backgroundImage) {
      const img = new Image();
      img.onload = () => {
        trackState.bgImage = img;
      };
      img.src = data.backgroundImage;
    }

    // Ensure we have enough start positions
    while (trackState.startPositions.length < 4) {
      const last = trackState.startPositions[trackState.startPositions.length - 1];
      trackState.startPositions.push({
        x: last.x + 20,
        y: last.y + 10,
        angle: last.angle || 0
      });
    }

    // Ensure we have a finish line
    if (!trackState.finishLine && trackState.waypoints.length >= 2) {
      const wp0 = trackState.waypoints[0];
      trackState.finishLine = {
        x1: wp0.x - 40, y1: wp0.y - 40,
        x2: wp0.x + 40, y2: wp0.y + 40
      };
    }

    return true;
  } catch (e) {
    alert('Error loading track: ' + e.message);
    return false;
  }
}

// File input handler
document.getElementById('track-file-input').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    if (loadTrackFromJSON(ev.target.result)) {
      // Track loaded, start the race
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    }
  };
  reader.readAsText(file);
  e.target.value = ''; // Reset so same file can be loaded again
});

// ========================================
// GRID UTILITIES
// ========================================

function getZoneAt(x, y) {
  const col = Math.floor(x / trackState.cellW);
  const row = Math.floor(y / trackState.cellH);
  if (col < 0 || col >= trackState.grid.cols || row < 0 || row >= trackState.grid.rows) return 0;
  return trackState.grid.data[row][col] || 0;
}

// Line segment intersection test (for finish line crossing)
function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
  const d1x = x2 - x1, d1y = y2 - y1;
  const d2x = x4 - x3, d2y = y4 - y3;
  const denom = d1x * d2y - d1y * d2x;
  if (Math.abs(denom) < 0.0001) return false;
  const t = ((x3 - x1) * d2y - (y3 - y1) * d2x) / denom;
  const u = ((x3 - x1) * d1y - (y3 - y1) * d1x) / denom;
  return t >= 0 && t <= 1 && u >= 0 && u <= 1;
}

// Get crossing direction (positive = correct direction)
function getCrossingDirection(x1, y1, x2, y2, fl) {
  // Use cross product to determine direction of crossing
  const dx = x2 - x1;
  const dy = y2 - y1;
  const flDx = fl.x2 - fl.x1;
  const flDy = fl.y2 - fl.y1;
  return dx * flDy - dy * flDx;
}

// ========================================
// UTILITY FUNCTIONS
// ========================================

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

function angleBetween(a, b) {
  return Math.atan2(b.y - a.y, b.x - a.x);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function normalizeAngle(a) {
  while (a > Math.PI) a -= Math.PI * 2;
  while (a < -Math.PI) a += Math.PI * 2;
  return a;
}

// ========================================
// OBSTACLES & PICKUPS
// ========================================

const obstacles = [];
const pickups = [];

function generateObstacles() {
  obstacles.length = 0;
  pickups.length = 0;

  // Place mines on track zones
  let attempts = 0;
  let minesPlaced = 0;
  while (minesPlaced < 5 && attempts < 200) {
    const x = Math.random() * W;
    const y = Math.random() * H;
    if (getZoneAt(x, y) === 'track') {
      // Don't place near start positions
      let nearStart = false;
      for (const sp of trackState.startPositions) {
        if (dist({x, y}, sp) < 80) { nearStart = true; break; }
      }
      if (!nearStart) {
        obstacles.push({ x, y, type: 'mine', radius: 8, active: true });
        minesPlaced++;
      }
    }
    attempts++;
  }

  // Place wrench pickups on track
  attempts = 0;
  let wrenchesPlaced = 0;
  while (wrenchesPlaced < 3 && attempts < 200) {
    const x = Math.random() * W;
    const y = Math.random() * H;
    if (getZoneAt(x, y) === 'track') {
      let nearStart = false;
      for (const sp of trackState.startPositions) {
        if (dist({x, y}, sp) < 60) { nearStart = true; break; }
      }
      if (!nearStart) {
        pickups.push({ x, y, type: 'wrench', radius: 10, active: true });
        wrenchesPlaced++;
      }
    }
    attempts++;
  }
}

// ========================================
// CAR CLASS
// ========================================

class Car {
  constructor(color, name, isPlayer) {
    this.color = color;
    this.name = name;
    this.isPlayer = isPlayer;
    this.x = 0;
    this.y = 0;
    this.angle = 0;
    this.speed = 0;
    this.maxSpeed = 3.2;
    this.acceleration = 0.06;
    this.braking = 0.08;
    this.turnSpeed = 0.04;
    this.friction = 0.985;
    this.offTrackFriction = 0.94;
    this.width = 18;
    this.height = 12;
    this.lap = 0;
    this.finished = false;
    this.finishTime = 0;

    // Previous position for finish line detection
    this.prevX = 0;
    this.prevY = 0;

    // Combat
    this.ammo = 10;
    this.missiles = 0;
    this.cooldown = 0;
    this.missileCooldown = 0;
    this.health = 100;
    this.stunTimer = 0;
    this.respawnTimer = 0;

    // Upgrades
    this.speedUpgrade = 0;
    this.accelUpgrade = 0;
    this.tireUpgrade = 0;

    // AI
    this.aiTargetIndex = 0;
    this.aiSteerNoise = 0;
    this.aiPersonality = {
      aggression: 0.3 + Math.random() * 0.5,
      accuracy: 0.7 + Math.random() * 0.3,
      nitroFreq: 0.002 + Math.random() * 0.004
    };

    // Visual
    this.dustParticles = [];
    this.wrenches = 0;
    this.nitro = 3;
    this.nitroActive = false;
    this.nitroTimer = 0;

    // Position tracking
    this.position = 0;
    this.totalProgress = 0;
    this.waypointProgress = 0;
  }

  applyUpgrades() {
    this.maxSpeed = 3.2 + this.speedUpgrade * 0.3;
    this.acceleration = 0.06 + this.accelUpgrade * 0.01;
    this.turnSpeed = 0.04 + this.tireUpgrade * 0.005;
  }

  reset(index) {
    const sp = trackState.startPositions[index] || trackState.startPositions[0];
    this.x = sp.x;
    this.y = sp.y;
    this.prevX = sp.x;
    this.prevY = sp.y;
    this.angle = sp.angle || 0;
    this.speed = 0;
    this.lap = 0;
    this.finished = false;
    this.finishTime = 0;
    this.health = 100;
    this.stunTimer = 0;
    this.respawnTimer = 0;
    this.ammo = 10;
    this.totalProgress = 0;
    this.waypointProgress = 0;
    this.dustParticles = [];

    // AI: find nearest waypoint
    if (!this.isPlayer && trackState.waypoints.length > 0) {
      let minD = Infinity;
      let minI = 0;
      for (let i = 0; i < trackState.waypoints.length; i++) {
        const d = dist(this, trackState.waypoints[i]);
        if (d < minD) { minD = d; minI = i; }
      }
      this.aiTargetIndex = (minI + 2) % trackState.waypoints.length;
    }

    this.applyUpgrades();
  }

  update(keys, dt, cars, bullets) {
    if (this.respawnTimer > 0) {
      this.respawnTimer -= dt;
      if (this.respawnTimer <= 0) {
        this.health = 100;
        this.stunTimer = 0;
      }
      return;
    }
    if (this.stunTimer > 0) {
      this.stunTimer -= dt;
      this.speed *= 0.95;
      return;
    }
    if (this.finished) return;

    // Save previous position for finish line detection
    this.prevX = this.x;
    this.prevY = this.y;

    if (this.isPlayer) {
      this.updatePlayer(keys, dt, bullets, cars);
    } else {
      this.updateAI(dt, cars, bullets);
    }

    // Nitro
    if (this.nitroActive && this.nitroTimer > 0) {
      this.nitroTimer -= dt;
      this.speed = Math.min(this.speed + 0.12, this.maxSpeed * 1.5);
      if (this.nitroTimer <= 0) {
        this.nitroActive = false;
      }
    }

    // Physics
    this.x += Math.cos(this.angle) * this.speed;
    this.y += Math.sin(this.angle) * this.speed;

    // Grid-based zone collision
    const zone = getZoneAt(this.x, this.y);
    this.applyZoneEffect(zone);

    // Apply base friction
    this.speed *= this.friction;

    // Clamp position
    this.x = Math.max(10, Math.min(W - 10, this.x));
    this.y = Math.max(10, Math.min(H - 10, this.y));

    // Finish line lap counting
    this.checkFinishLine();

    // Cooldown
    if (this.cooldown > 0) this.cooldown -= dt;
    if (this.missileCooldown > 0) this.missileCooldown -= dt;

    // Dust particles
    if (Math.abs(this.speed) > 1) {
      if (Math.random() < 0.3) {
        this.dustParticles.push({
          x: this.x - Math.cos(this.angle) * 10 + (Math.random() - 0.5) * 6,
          y: this.y - Math.sin(this.angle) * 10 + (Math.random() - 0.5) * 6,
          life: 20,
          maxLife: 20,
          size: 2 + Math.random() * 3
        });
      }
    }
    this.dustParticles = this.dustParticles.filter(p => {
      p.life--;
      return p.life > 0;
    });

    // Obstacle collision
    for (const obs of obstacles) {
      if (!obs.active) continue;
      if (dist(this, obs) < obs.radius + 10) {
        if (obs.type === 'mine') {
          this.health -= 30;
          this.stunTimer = 40;
          this.speed *= -0.3;
          obs.active = false;
          explosions.push(createExplosion(obs.x, obs.y));
          if (this.health <= 0) {
            this.respawn();
          }
        }
      }
    }

    // Pickup collision
    for (const p of pickups) {
      if (!p.active) continue;
      if (dist(this, p) < p.radius + 10) {
        if (p.type === 'wrench') {
          this.wrenches++;
          p.active = false;
        }
      }
    }

    // Car collision
    for (const other of cars) {
      if (other === this) continue;
      const d = dist(this, other);
      if (d < 18 && d > 0) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const pushForce = (18 - d) * 0.3;
        this.x += (dx / d) * pushForce;
        this.y += (dy / d) * pushForce;
        other.x -= (dx / d) * pushForce * 0.5;
        other.y -= (dy / d) * pushForce * 0.5;
        this.speed *= 0.9;
      }
    }
  }

  applyZoneEffect(zone) {
    switch (zone) {
      case 'wall':
        // Bounce back - reverse movement and reduce speed
        this.x = this.prevX;
        this.y = this.prevY;
        this.speed *= -0.3;
        break;
      case 'hazard':
        // Slow down and take damage over time
        this.speed *= 0.96;
        if (Math.random() < 0.02) {
          this.health -= 1;
          if (this.health <= 0) this.respawn();
        }
        break;
      case 'boost':
        // Speed boost
        this.speed = Math.min(this.speed + 0.15, this.maxSpeed * 1.4);
        break;
      case 'pit':
        // Heal and slow slightly
        this.health = Math.min(100, this.health + 0.3);
        this.speed *= 0.99;
        break;
      case 'track':
        // Normal surface - no special effect
        break;
      default:
        // Off-track (0 or empty) - heavy friction
        this.speed *= this.offTrackFriction;
        break;
    }
  }

  respawn() {
    this.respawnTimer = 120;
    this.health = 0;
    // Respawn at nearest waypoint
    if (trackState.waypoints.length > 0) {
      let minD = Infinity;
      let minWP = trackState.waypoints[0];
      for (const wp of trackState.waypoints) {
        const d = dist(this, wp);
        if (d < minD) { minD = d; minWP = wp; }
      }
      this.x = minWP.x;
      this.y = minWP.y;
    }
  }

  checkFinishLine() {
    if (!trackState.finishLine) return;
    const fl = trackState.finishLine;

    // Check if car path crosses the finish line
    const crossed = linesIntersect(
      this.prevX, this.prevY, this.x, this.y,
      fl.x1, fl.y1, fl.x2, fl.y2
    );

    if (crossed) {
      const dir = getCrossingDirection(this.prevX, this.prevY, this.x, this.y, fl);
      if (dir > 0) {
        // Forward crossing
        this.lap++;
        if (this.lap >= trackState.laps && !this.finished) {
          this.finished = true;
          this.finishTime = raceTime;
        }
      } else if (dir < 0 && this.lap > 0) {
        // Backward crossing
        this.lap--;
      }
    }

    // Update total progress for position tracking
    this.updateProgress();
  }

  updateProgress() {
    // Progress = completed laps + fractional progress based on nearest waypoint
    if (trackState.waypoints.length === 0) {
      this.totalProgress = this.lap;
      return;
    }
    let minD = Infinity;
    let minI = 0;
    for (let i = 0; i < trackState.waypoints.length; i++) {
      const d = dist(this, trackState.waypoints[i]);
      if (d < minD) { minD = d; minI = i; }
    }
    this.waypointProgress = minI;
    this.totalProgress = this.lap * trackState.waypoints.length + minI;
  }

  updatePlayer(keys, dt, bullets, cars) {
    if (keys['ArrowUp'] || keys['w']) {
      this.speed += this.acceleration;
    }
    if (keys['ArrowDown'] || keys['s']) {
      this.speed -= this.braking;
    }
    if (this.speed > this.maxSpeed) this.speed = this.maxSpeed;
    if (this.speed < -this.maxSpeed * 0.3) this.speed = -this.maxSpeed * 0.3;

    const turnFactor = Math.min(Math.abs(this.speed) / 2, 1);
    if (keys['ArrowLeft'] || keys['a']) {
      this.angle -= this.turnSpeed * turnFactor;
    }
    if (keys['ArrowRight'] || keys['d']) {
      this.angle += this.turnSpeed * turnFactor;
    }

    // Shoot cannon
    if (keys[' '] && this.cooldown <= 0 && this.ammo > 0) {
      this.shootCannon(bullets);
      keys[' '] = false;
    }

    // Shoot missile
    if (keys['m'] && this.missileCooldown <= 0 && this.missiles > 0) {
      this.shootMissile(bullets, cars);
      keys['m'] = false;
    }

    // Nitro
    if (keys['n'] && this.nitro > 0 && !this.nitroActive) {
      this.nitroActive = true;
      this.nitroTimer = 30;
      this.nitro--;
      keys['n'] = false;
    }
  }

  updateAI(dt, cars, bullets) {
    if (trackState.waypoints.length === 0) return;

    // Follow waypoints
    const target = trackState.waypoints[this.aiTargetIndex];
    const distToTarget = dist(this, target);

    // Advance to next waypoint when close enough
    if (distToTarget < 40) {
      this.aiTargetIndex = (this.aiTargetIndex + 1) % trackState.waypoints.length;
    }

    // Look ahead a few waypoints for smoother steering
    const lookAheadIdx = (this.aiTargetIndex + 2) % trackState.waypoints.length;
    const lookAheadTarget = trackState.waypoints[lookAheadIdx];

    // Blend between current and look-ahead target
    const steerTarget = {
      x: lerp(target.x, lookAheadTarget.x, 0.3),
      y: lerp(target.y, lookAheadTarget.y, 0.3)
    };

    const targetAngle = angleBetween(this, steerTarget);
    let angleDiff = normalizeAngle(targetAngle - this.angle);

    // Steering noise for variety
    this.aiSteerNoise += (Math.random() - 0.5) * 0.005;
    this.aiSteerNoise *= 0.98;

    const steer = Math.max(-this.turnSpeed, Math.min(this.turnSpeed,
      angleDiff * 0.15 * this.aiPersonality.accuracy + this.aiSteerNoise));
    this.angle += steer;

    // Accelerate
    if (Math.abs(angleDiff) < 0.8) {
      this.speed += this.acceleration * 0.9;
    } else {
      this.speed += this.acceleration * 0.4;
    }
    if (this.speed > this.maxSpeed * 0.92) this.speed = this.maxSpeed * 0.92;

    // AI shooting - shoot at nearby cars ahead
    if (this.cooldown <= 0 && this.ammo > 0 && Math.random() < 0.02 * this.aiPersonality.aggression) {
      for (const other of cars) {
        if (other === this) continue;
        const d = dist(this, other);
        if (d < 150) {
          const aToOther = angleBetween(this, other);
          let aDiff = normalizeAngle(aToOther - this.angle);
          if (Math.abs(aDiff) < 0.5) {
            this.shootCannon(bullets);
            break;
          }
        }
      }
    }

    // AI missile usage
    if (this.missileCooldown <= 0 && this.missiles > 0 && Math.random() < 0.005 * this.aiPersonality.aggression) {
      this.shootMissile(bullets, cars);
    }

    // AI nitro occasionally
    if (this.nitro > 0 && !this.nitroActive && Math.random() < this.aiPersonality.nitroFreq) {
      this.nitroActive = true;
      this.nitroTimer = 30;
      this.nitro--;
    }
  }

  shootCannon(bullets) {
    if (this.cooldown > 0 || this.ammo <= 0) return;
    bullets.push({
      x: this.x + Math.cos(this.angle) * 15,
      y: this.y + Math.sin(this.angle) * 15,
      vx: Math.cos(this.angle) * 6 + this.speed * Math.cos(this.angle) * 0.3,
      vy: Math.sin(this.angle) * 6 + this.speed * Math.sin(this.angle) * 0.3,
      owner: this,
      life: 60,
      isMissile: false,
      target: null
    });
    this.ammo--;
    this.cooldown = 12;
  }

  shootMissile(bullets, cars) {
    if (this.missileCooldown > 0 || this.missiles <= 0) return;

    // Find nearest opponent to target
    let nearestCar = null;
    let nearestDist = Infinity;
    for (const other of cars) {
      if (other === this) continue;
      const d = dist(this, other);
      if (d < nearestDist && d < 400) {
        nearestDist = d;
        nearestCar = other;
      }
    }

    bullets.push({
      x: this.x + Math.cos(this.angle) * 15,
      y: this.y + Math.sin(this.angle) * 15,
      vx: Math.cos(this.angle) * 4,
      vy: Math.sin(this.angle) * 4,
      owner: this,
      life: 180, // Missiles last longer
      isMissile: true,
      target: nearestCar, // Homing target
      turnRate: 0.06
    });
    this.missiles--;
    this.missileCooldown = 60;
  }

  draw(ctx) {
    // Draw dust
    for (const p of this.dustParticles) {
      const alpha = p.life / p.maxLife * 0.4;
      ctx.fillStyle = `rgba(160,140,100,${alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    }

    if (this.respawnTimer > 0) {
      if (Math.floor(this.respawnTimer / 5) % 2 === 0) return;
    }

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);

    // Car shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-this.width / 2 + 2, -this.height / 2 + 2, this.width, this.height);

    // Car body
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

    // Windshield
    ctx.fillStyle = '#1a1a2a';
    ctx.fillRect(2, -this.height / 2 + 2, 5, this.height - 4);

    // Cannon
    ctx.fillStyle = '#444';
    ctx.fillRect(this.width / 2 - 2, -2, 6, 4);

    // Missile launcher indicator
    if (this.missiles > 0) {
      ctx.fillStyle = '#a00';
      ctx.fillRect(this.width / 2 - 2, -5, 4, 2);
      ctx.fillRect(this.width / 2 - 2, 3, 4, 2);
    }

    // Nitro flame
    if (this.nitroActive) {
      ctx.fillStyle = `rgba(255,${100 + Math.random() * 155},0,0.8)`;
      ctx.fillRect(-this.width / 2 - 8 - Math.random() * 5, -3, 8 + Math.random() * 4, 6);
    }

    // Stun indicator
    if (this.stunTimer > 0) {
      ctx.strokeStyle = '#ff0';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const a = Math.random() * Math.PI * 2;
        const r = 12 + Math.random() * 5;
        ctx.beginPath();
        ctx.moveTo(Math.cos(a) * r, Math.sin(a) * r);
        ctx.lineTo(Math.cos(a + 0.3) * (r + 4), Math.sin(a + 0.3) * (r + 4));
        ctx.stroke();
      }
    }

    ctx.restore();

    // Health bar
    if (this.health < 100) {
      const barW = 20;
      const barH = 3;
      ctx.fillStyle = '#300';
      ctx.fillRect(this.x - barW / 2, this.y - 14, barW, barH);
      ctx.fillStyle = this.health > 50 ? '#0a0' : (this.health > 25 ? '#aa0' : '#a00');
      ctx.fillRect(this.x - barW / 2, this.y - 14, barW * (this.health / 100), barH);
    }
  }
}

// ========================================
// EXPLOSIONS
// ========================================

let explosions = [];

function createExplosion(x, y) {
  const particles = [];
  for (let i = 0; i < 20; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    particles.push({
      x: x, y: y,
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd,
      life: 20 + Math.random() * 20,
      maxLife: 40,
      size: 2 + Math.random() * 4,
      color: Math.random() < 0.5 ? '#ff6600' : '#ffcc00'
    });
  }
  return { particles };
}

// ========================================
// BULLETS & MISSILES
// ========================================

let bullets = [];

function updateBullets(cars) {
  bullets = bullets.filter(b => {
    // Missile homing behavior
    if (b.isMissile && b.target && b.target.health > 0 && b.target.respawnTimer <= 0) {
      const targetAngle = angleBetween(b, b.target);
      const currentAngle = Math.atan2(b.vy, b.vx);
      let angleDiff = normalizeAngle(targetAngle - currentAngle);
      const turn = Math.max(-b.turnRate, Math.min(b.turnRate, angleDiff));
      const newAngle = currentAngle + turn;
      const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
      b.vx = Math.cos(newAngle) * speed;
      b.vy = Math.sin(newAngle) * speed;
      // Missiles accelerate slightly
      b.vx *= 1.005;
      b.vy *= 1.005;
    }

    b.x += b.vx;
    b.y += b.vy;
    b.life--;

    // Check wall collision
    if (getZoneAt(b.x, b.y) === 'wall') {
      explosions.push(createExplosion(b.x, b.y));
      return false;
    }

    // Check car hits
    for (const car of cars) {
      if (car === b.owner) continue;
      if (dist(b, car) < 14) {
        const damage = b.isMissile ? 35 : 15;
        car.health -= damage;
        car.stunTimer = b.isMissile ? 30 : 15;
        car.speed *= b.isMissile ? 0.2 : 0.5;
        explosions.push(createExplosion(b.x, b.y));
        if (car.health <= 0) {
          car.respawn();
        }
        return false;
      }
    }

    // Out of bounds
    if (b.x < 0 || b.x > W || b.y < 0 || b.y > H) return false;

    return b.life > 0;
  });
}

function drawBullets() {
  for (const b of bullets) {
    if (b.isMissile) {
      // Missile: red triangle shape
      const angle = Math.atan2(b.vy, b.vx);
      ctx.save();
      ctx.translate(b.x, b.y);
      ctx.rotate(angle);
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.moveTo(5, 0);
      ctx.lineTo(-4, -3);
      ctx.lineTo(-4, 3);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // Missile trail
      ctx.strokeStyle = 'rgba(255,100,0,0.6)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx * 4, b.y - b.vy * 4);
      ctx.stroke();
      // Smoke puffs
      if (Math.random() < 0.5) {
        ctx.fillStyle = 'rgba(150,150,150,0.3)';
        ctx.beginPath();
        ctx.arc(b.x - b.vx * 3 + (Math.random() - 0.5) * 4,
                b.y - b.vy * 3 + (Math.random() - 0.5) * 4,
                2 + Math.random() * 2, 0, Math.PI * 2);
        ctx.fill();
      }
    } else {
      // Cannon bullet: yellow dot
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(b.x, b.y, 2, 0, Math.PI * 2);
      ctx.fill();
      // Trail
      ctx.strokeStyle = 'rgba(255,255,0,0.3)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(b.x, b.y);
      ctx.lineTo(b.x - b.vx * 3, b.y - b.vy * 3);
      ctx.stroke();
    }
  }
}

// ========================================
// TRACK RENDERING
// ========================================

// Zone rendering colors (more opaque for default, semi-transparent for custom)
const ZONE_RENDER_COLORS = {
  track:  { default: '#4a3a2a', overlay: 'rgba(0,180,0,0.15)' },
  wall:   { default: '#2a1a0a', overlay: 'rgba(180,0,0,0.25)' },
  hazard: { default: '#5a5a10', overlay: 'rgba(180,180,0,0.3)' },
  boost:  { default: '#2a3a5a', overlay: 'rgba(0,150,255,0.25)' },
  pit:    { default: '#3a2a4a', overlay: 'rgba(150,0,180,0.25)' },
};

function drawTrack() {
  const ts = trackState;

  if (ts.isCustom) {
    // Custom track: draw background image + zone overlay
    drawCustomTrack();
  } else {
    // Default track: draw with built-in styling
    drawDefaultTrack();
  }

  // Draw finish line
  if (ts.finishLine) {
    const fl = ts.finishLine;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(fl.x1, fl.y1);
    ctx.lineTo(fl.x2, fl.y2);
    ctx.stroke();

    // Checkerboard
    const dx = fl.x2 - fl.x1;
    const dy = fl.y2 - fl.y1;
    const len = Math.sqrt(dx * dx + dy * dy);
    const steps = Math.floor(len / 8);
    for (let i = 0; i < steps; i++) {
      const t = i / steps;
      const px = fl.x1 + dx * t;
      const py = fl.y1 + dy * t;
      ctx.fillStyle = i % 2 === 0 ? '#eee' : '#222';
      ctx.fillRect(px - 3, py - 3, 6, 6);
    }
  }
}

function drawDefaultTrack() {
  const ts = trackState;

  // Ground
  ctx.fillStyle = groundColor;
  ctx.fillRect(0, 0, W, H);

  // Ground texture
  ctx.fillStyle = '#222218';
  for (let i = 0; i < 80; i++) {
    const rx = (i * 137.5 + 50) % W;
    const ry = (i * 89.3 + 30) % H;
    ctx.fillRect(rx, ry, 2 + (i % 3), 2 + (i % 2));
  }

  // Draw zones from grid
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      if (zone && ZONE_RENDER_COLORS[zone]) {
        ctx.fillStyle = ZONE_RENDER_COLORS[zone].default;
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      }
    }
  }

  // Draw special zone indicators
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      const cx = c * ts.cellW + ts.cellW / 2;
      const cy = r * ts.cellH + ts.cellH / 2;

      if (zone === 'hazard') {
        // Yellow warning stripes
        ctx.fillStyle = 'rgba(200,180,0,0.3)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      } else if (zone === 'boost') {
        // Blue arrows
        ctx.fillStyle = 'rgba(0,120,255,0.2)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
        // Arrow symbol
        if ((r + c) % 3 === 0) {
          ctx.fillStyle = 'rgba(100,200,255,0.4)';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('>', cx, cy + 3);
          ctx.textAlign = 'left';
        }
      } else if (zone === 'pit') {
        // Purple cross
        ctx.fillStyle = 'rgba(180,50,220,0.2)';
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
        if ((r + c) % 3 === 0) {
          ctx.fillStyle = 'rgba(200,100,255,0.5)';
          ctx.font = '8px monospace';
          ctx.textAlign = 'center';
          ctx.fillText('+', cx, cy + 3);
          ctx.textAlign = 'left';
        }
      }
    }
  }

  // Track border effect - draw wall outlines
  ctx.strokeStyle = trackBorderColor;
  ctx.lineWidth = 1;
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      if (ts.grid.data[r][c] === 'wall') {
        // Only draw border on edges adjacent to track
        const x = c * ts.cellW;
        const y = r * ts.cellH;
        if (c > 0 && ts.grid.data[r][c - 1] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x, y + ts.cellH); ctx.stroke();
        }
        if (c < ts.grid.cols - 1 && ts.grid.data[r][c + 1] === 'track') {
          ctx.beginPath(); ctx.moveTo(x + ts.cellW, y); ctx.lineTo(x + ts.cellW, y + ts.cellH); ctx.stroke();
        }
        if (r > 0 && ts.grid.data[r - 1][c] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + ts.cellW, y); ctx.stroke();
        }
        if (r < ts.grid.rows - 1 && ts.grid.data[r + 1][c] === 'track') {
          ctx.beginPath(); ctx.moveTo(x, y + ts.cellH); ctx.lineTo(x + ts.cellW, y + ts.cellH); ctx.stroke();
        }
      }
    }
  }

  // Environment decorations
  drawEnvironment();
}

function drawCustomTrack() {
  const ts = trackState;

  // Background image or dark ground
  if (ts.bgImage) {
    ctx.drawImage(ts.bgImage, 0, 0, W, H);
  } else {
    ctx.fillStyle = '#1a1a12';
    ctx.fillRect(0, 0, W, H);
  }

  // Semi-transparent zone overlay
  for (let r = 0; r < ts.grid.rows; r++) {
    for (let c = 0; c < ts.grid.cols; c++) {
      const zone = ts.grid.data[r][c];
      if (zone && ZONE_RENDER_COLORS[zone]) {
        ctx.fillStyle = ZONE_RENDER_COLORS[zone].overlay;
        ctx.fillRect(c * ts.cellW, r * ts.cellH, ts.cellW + 0.5, ts.cellH + 0.5);
      }
    }
  }
}

function drawEnvironment() {
  // Rusty barrels (positioned in off-track areas)
  const barrels = [
    {x: 450, y: 300}, {x: 460, y: 310}, {x: 455, y: 320},
    {x: 300, y: 200}, {x: 650, y: 400},
    {x: 500, y: 150}, {x: 180, y: 450}
  ];
  for (const b of barrels) {
    if (getZoneAt(b.x, b.y) !== 'track') {
      ctx.fillStyle = '#654321';
      ctx.beginPath();
      ctx.arc(b.x, b.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#432';
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.fillStyle = '#543210';
      ctx.fillRect(b.x - 4, b.y - 1, 8, 2);
    }
  }

  // Wrecked cars
  const wrecks = [
    {x: 430, y: 280, a: 0.5}, {x: 550, y: 350, a: 1.2}, {x: 250, y: 380, a: 2.1}
  ];
  for (const w of wrecks) {
    if (getZoneAt(w.x, w.y) !== 'track') {
      ctx.save();
      ctx.translate(w.x, w.y);
      ctx.rotate(w.a);
      ctx.fillStyle = '#3a3a3a';
      ctx.fillRect(-12, -7, 24, 14);
      ctx.fillStyle = '#2a2a2a';
      ctx.fillRect(-8, -5, 16, 10);
      ctx.restore();
    }
  }

  // Warning signs
  ctx.fillStyle = '#aa0';
  ctx.font = 'bold 10px monospace';
  ctx.fillText('DANGER', 420, 270);
  ctx.fillText('NO EXIT', 530, 340);

  // Pipes along edges
  ctx.strokeStyle = '#555';
  ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(50, 50); ctx.lineTo(50, 650); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(850, 50); ctx.lineTo(850, 650); ctx.stroke();

  // Tower structures
  drawTower(60, 60);
  drawTower(840, 60);
  drawTower(60, 640);
  drawTower(840, 640);
}

function drawTower(x, y) {
  ctx.fillStyle = '#444';
  ctx.fillRect(x - 8, y - 8, 16, 16);
  ctx.fillStyle = '#333';
  ctx.fillRect(x - 5, y - 20, 10, 12);
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(x, y - 20);
  ctx.lineTo(x, y - 30);
  ctx.stroke();
  if (Math.floor(Date.now() / 500) % 2 === 0) {
    ctx.fillStyle = '#f00';
    ctx.beginPath();
    ctx.arc(x, y - 30, 2, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ========================================
// DRAW OBSTACLES & PICKUPS
// ========================================

function drawObstacles() {
  for (const obs of obstacles) {
    if (!obs.active) continue;
    if (obs.type === 'mine') {
      ctx.fillStyle = '#660000';
      ctx.beginPath();
      ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#ff0000';
      ctx.lineWidth = 1;
      ctx.stroke();
      if (Math.floor(Date.now() / 300) % 2 === 0) {
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(obs.x, obs.y, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  for (const p of pickups) {
    if (!p.active) continue;
    if (p.type === 'wrench') {
      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(Date.now() / 500);
      ctx.fillStyle = '#ccc';
      ctx.fillRect(-3, -8, 6, 16);
      ctx.fillRect(-8, -3, 16, 6);
      ctx.restore();
      ctx.fillStyle = 'rgba(200,200,255,0.15)';
      ctx.beginPath();
      ctx.arc(p.x, p.y, 14, 0, Math.PI * 2);
      ctx.fill();
    }
  }
}

// ========================================
// DRAW EXPLOSIONS
// ========================================

function drawExplosions() {
  explosions = explosions.filter(e => {
    let alive = false;
    for (const p of e.particles) {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      p.life--;
      if (p.life > 0) {
        alive = true;
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = p.color.replace(')', `,${alpha})`).replace('rgb', 'rgba');
        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.globalAlpha = 1;
    return alive;
  });
}

// ========================================
// HUD
// ========================================

function drawHUD(player, cars) {
  const sorted = [...cars].sort((a, b) => b.totalProgress - a.totalProgress);
  const playerPos = sorted.indexOf(player) + 1;

  // Bottom HUD bar
  ctx.fillStyle = 'rgba(0,0,0,0.75)';
  ctx.fillRect(0, H - 50, W, 50);

  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 14px monospace';

  // Position
  ctx.fillText(`POS: ${playerPos}/${cars.length}`, 20, H - 30);

  // Lap
  ctx.fillText(`LAP: ${Math.min(player.lap + 1, trackState.laps)}/${trackState.laps}`, 160, H - 30);

  // Speed bar
  ctx.fillStyle = '#333';
  ctx.fillRect(280, H - 38, 80, 14);
  const speedPct = Math.abs(player.speed) / player.maxSpeed;
  ctx.fillStyle = player.nitroActive ? '#00aaff' : '#ff6600';
  ctx.fillRect(280, H - 38, 80 * speedPct, 14);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.fillText('SPEED', 300, H - 28);

  // Ammo
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 14px monospace';
  ctx.fillText(`AMMO:${player.ammo}`, 380, H - 30);

  // Missiles
  ctx.fillStyle = '#ff3333';
  ctx.fillText(`MSL:${player.missiles}`, 470, H - 30);

  // Health bar
  ctx.fillStyle = '#333';
  ctx.fillRect(550, H - 38, 80, 14);
  ctx.fillStyle = player.health > 50 ? '#00aa00' : (player.health > 25 ? '#aaaa00' : '#aa0000');
  ctx.fillRect(550, H - 38, 80 * (player.health / 100), 14);
  ctx.fillStyle = '#fff';
  ctx.font = '10px monospace';
  ctx.fillText('HEALTH', 568, H - 28);

  // Nitro
  ctx.fillStyle = '#00aaff';
  ctx.font = 'bold 14px monospace';
  ctx.fillText(`NIT:${player.nitro}`, 650, H - 30);

  // Wrenches
  ctx.fillStyle = '#ccc';
  ctx.fillText(`WRENCHES:${player.wrenches}`, 720, H - 30);

  // Race time
  const secs = Math.floor(raceTime / 60);
  const mins = Math.floor(secs / 60);
  const displaySecs = secs % 60;
  ctx.fillStyle = '#ff6600';
  ctx.fillText(`${mins}:${displaySecs.toString().padStart(2, '0')}`, 860, H - 30);

  // Zone indicator
  const currentZone = getZoneAt(player.x, player.y);
  if (currentZone && currentZone !== 'track') {
    let zoneText = '';
    let zoneColor = '#fff';
    switch (currentZone) {
      case 'boost': zoneText = 'BOOST!'; zoneColor = '#00aaff'; break;
      case 'hazard': zoneText = 'HAZARD!'; zoneColor = '#ffaa00'; break;
      case 'pit': zoneText = 'PIT STOP'; zoneColor = '#aa55ff'; break;
      case 'wall': zoneText = 'WALL'; zoneColor = '#ff3333'; break;
    }
    if (zoneText) {
      ctx.fillStyle = zoneColor;
      ctx.font = 'bold 16px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(zoneText, W / 2, H - 60);
      ctx.textAlign = 'left';
    }
  }

  // Top position bar
  ctx.fillStyle = '#222';
  ctx.fillRect(0, 0, W, 24);
  for (let i = 0; i < sorted.length; i++) {
    const c = sorted[i];
    ctx.fillStyle = c.color;
    ctx.font = 'bold 12px monospace';
    ctx.fillText(`${i + 1}. ${c.name}  LAP ${Math.min(c.lap + 1, trackState.laps)}`, 20 + i * 230, 16);
  }
}

// ========================================
// MENU SCREEN
// ========================================

function drawMenu() {
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);

  // Animated background - moving diagonal lines
  const t = Date.now() / 1000;
  ctx.strokeStyle = 'rgba(255,100,0,0.04)';
  ctx.lineWidth = 1;
  for (let i = 0; i < 30; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * 25 + Math.sin(t + i * 0.5) * 12);
    ctx.lineTo(W, i * 25 + Math.cos(t + i * 0.5) * 12);
    ctx.stroke();
  }
  // Vertical accent lines
  for (let i = 0; i < 15; i++) {
    ctx.beginPath();
    ctx.moveTo(i * 65 + Math.sin(t * 0.7 + i) * 8, 0);
    ctx.lineTo(i * 65 + Math.cos(t * 0.7 + i) * 8, H);
    ctx.stroke();
  }

  // Title with glow effect
  ctx.shadowColor = '#ff6600';
  ctx.shadowBlur = 20;
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 56px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('WASTELAND', W / 2, 140);
  ctx.fillStyle = '#cc4400';
  ctx.font = 'bold 72px monospace';
  ctx.fillText('RACERS', W / 2, 215);
  ctx.shadowBlur = 0;

  // Subtitle
  ctx.fillStyle = '#886644';
  ctx.font = '14px monospace';
  ctx.fillText('POST-APOCALYPTIC COMBAT RACING', W / 2, 250);

  // Decorative line
  ctx.strokeStyle = '#ff6600';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 200, 270);
  ctx.lineTo(W / 2 + 200, 270);
  ctx.stroke();
  ctx.strokeStyle = '#663300';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 250, 275);
  ctx.lineTo(W / 2 + 250, 275);
  ctx.stroke();

  // Menu options
  const menuItems = [
    { label: 'START RACE', desc: 'Choose a track and race' },
    { label: 'HIGHSCORES', desc: 'View best times and records' }
  ];

  for (let i = 0; i < menuItems.length; i++) {
    const y = 340 + i * 80;
    const selected = menuSelection === i;

    // Selection box
    if (selected) {
      ctx.fillStyle = 'rgba(255,102,0,0.15)';
      ctx.fillRect(W / 2 - 200, y - 25, 400, 55);
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.strokeRect(W / 2 - 200, y - 25, 400, 55);
    }

    // Arrow indicator
    if (selected) {
      const blink = Math.floor(Date.now() / 300) % 2;
      ctx.fillStyle = blink ? '#ff6600' : '#ff9933';
      ctx.font = 'bold 24px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('>', W / 2 - 160, y + 8);
      ctx.textAlign = 'left';
      ctx.fillText('<', W / 2 + 160, y + 8);
    }

    ctx.fillStyle = selected ? '#ff6600' : '#886644';
    ctx.font = 'bold 28px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(menuItems[i].label, W / 2, y + 8);

    ctx.fillStyle = selected ? '#aa8866' : '#554433';
    ctx.font = '12px monospace';
    ctx.fillText(menuItems[i].desc, W / 2, y + 26);
  }

  // Progress info
  ctx.fillStyle = '#554433';
  ctx.font = '14px monospace';
  ctx.fillText(`Tracks Unlocked: ${progression.unlockedTracks}/${TRACK_DEFS.length}`, W / 2, 540);

  // Wrenches & Money
  ctx.fillStyle = '#ccc';
  ctx.font = '14px monospace';
  ctx.fillText(`Money: ${progression.money} | Total Wrenches: ${progression.totalWrenches}`, W / 2, 565);

  // Controls hint
  ctx.fillStyle = '#443322';
  ctx.font = '12px monospace';
  ctx.fillText('UP/DOWN to select  |  ENTER to confirm  |  L to load custom track', W / 2, 610);

  // Controls reference
  ctx.fillStyle = '#332211';
  ctx.font = '11px monospace';
  ctx.fillText('WASD/Arrows: Drive  |  SPACE: Cannon  |  M: Missile  |  N: Nitro', W / 2, 640);

  // Version info
  ctx.fillStyle = '#333';
  ctx.font = '10px monospace';
  ctx.fillText('v3.1 - Playable on GitHub Pages', W / 2, 680);

  ctx.textAlign = 'left';
}

// ========================================
// TRACK SELECT SCREEN
// ========================================

let trackSelectCursor = 0;

function drawTrackSelect() {
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 36px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT TRACK', W / 2, 55);

  // Decorative line
  ctx.strokeStyle = '#663300';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 200, 70);
  ctx.lineTo(W / 2 + 200, 70);
  ctx.stroke();

  // Track list
  for (let i = 0; i < TRACK_DEFS.length; i++) {
    const def = TRACK_DEFS[i];
    const y = 105 + i * 105;
    const unlocked = i < progression.unlockedTracks;
    const selected = trackSelectCursor === i;

    // Background card
    ctx.fillStyle = selected ? 'rgba(255,102,0,0.12)' : 'rgba(30,30,25,0.8)';
    ctx.fillRect(80, y - 10, W - 160, 90);

    if (selected) {
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 2;
      ctx.strokeRect(80, y - 10, W - 160, 90);
    } else {
      ctx.strokeStyle = unlocked ? '#443322' : '#222';
      ctx.lineWidth = 1;
      ctx.strokeRect(80, y - 10, W - 160, 90);
    }

    if (unlocked) {
      // Track number
      ctx.fillStyle = selected ? '#ff6600' : '#886644';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`${i + 1}`, 105, y + 30);

      // Track name
      ctx.fillStyle = selected ? '#ff9933' : '#aa8866';
      ctx.font = 'bold 22px monospace';
      ctx.fillText(def.name, 150, y + 18);

      // Difficulty
      const diffColors = { 'EASY': '#44aa44', 'MEDIUM': '#aaaa44', 'HARD': '#cc6633', 'EXTREME': '#cc3333' };
      ctx.fillStyle = diffColors[def.difficulty] || '#888';
      ctx.font = 'bold 12px monospace';
      ctx.fillText(`[${def.difficulty}]`, 150, y + 38);

      // Description
      ctx.fillStyle = '#666';
      ctx.font = '12px monospace';
      ctx.fillText(def.description, 150, y + 55);

      // Laps info
      ctx.fillStyle = '#555';
      ctx.font = '11px monospace';
      ctx.textAlign = 'right';
      ctx.fillText(`${def.laps} LAPS`, W - 110, y + 18);

      // Reward info
      ctx.fillStyle = '#888';
      ctx.fillText(`1st: $${def.reward[0]}`, W - 110, y + 38);

      // Highscore
      const hs = progression.highscores[def.name];
      if (hs) {
        ctx.fillStyle = '#44aa44';
        ctx.fillText(`BEST: ${formatTime(hs.bestTime)}`, W - 110, y + 55);
      } else {
        ctx.fillStyle = '#443322';
        ctx.fillText('NO RECORD', W - 110, y + 55);
      }
      ctx.textAlign = 'left';
    } else {
      // Locked track
      ctx.fillStyle = '#333';
      ctx.font = 'bold 32px monospace';
      ctx.textAlign = 'left';
      ctx.fillText(`${i + 1}`, 105, y + 30);

      ctx.fillStyle = '#555';
      ctx.font = 'bold 22px monospace';
      ctx.fillText('LOCKED', 150, y + 18);

      ctx.fillStyle = '#443322';
      ctx.font = '12px monospace';
      ctx.fillText(`Complete Track ${i} to unlock`, 150, y + 40);

      // Lock icon
      ctx.fillStyle = '#555';
      ctx.font = 'bold 28px monospace';
      ctx.textAlign = 'right';
      ctx.fillText('[X]', W - 110, y + 30);
      ctx.textAlign = 'left';
    }
  }

  // Bottom controls
  ctx.fillStyle = '#886644';
  ctx.font = '14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('UP/DOWN: Select  |  ENTER: Race  |  ESC: Back', W / 2, H - 25);
  ctx.textAlign = 'left';
}

// ========================================
// HIGHSCORES SCREEN
// ========================================

function drawHighscores() {
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.shadowColor = '#ff6600';
  ctx.shadowBlur = 15;
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 40px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('HALL OF FAME', W / 2, 70);
  ctx.shadowBlur = 0;

  // Decorative line
  ctx.strokeStyle = '#663300';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 200, 85);
  ctx.lineTo(W / 2 + 200, 85);
  ctx.stroke();

  // Column headers
  ctx.fillStyle = '#886644';
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'left';
  ctx.fillText('#', 100, 120);
  ctx.fillText('TRACK', 130, 120);
  ctx.fillText('DIFFICULTY', 400, 120);
  ctx.fillText('BEST TIME', 550, 120);
  ctx.fillText('BEST POS', 700, 120);

  ctx.strokeStyle = '#443322';
  ctx.beginPath();
  ctx.moveTo(90, 128);
  ctx.lineTo(810, 128);
  ctx.stroke();

  // Track entries
  for (let i = 0; i < TRACK_DEFS.length; i++) {
    const def = TRACK_DEFS[i];
    const y = 160 + i * 50;
    const hs = progression.highscores[def.name];
    const unlocked = i < progression.unlockedTracks;

    // Row background
    ctx.fillStyle = i % 2 === 0 ? 'rgba(30,30,25,0.5)' : 'rgba(20,20,15,0.5)';
    ctx.fillRect(90, y - 15, 720, 40);

    ctx.textAlign = 'left';
    ctx.fillStyle = unlocked ? '#aa8866' : '#444';
    ctx.font = 'bold 16px monospace';
    ctx.fillText(`${i + 1}`, 100, y + 8);

    ctx.fillStyle = unlocked ? '#cc9966' : '#555';
    ctx.font = 'bold 18px monospace';
    ctx.fillText(unlocked ? def.name : '???', 130, y + 8);

    const diffColors = { 'EASY': '#44aa44', 'MEDIUM': '#aaaa44', 'HARD': '#cc6633', 'EXTREME': '#cc3333' };
    ctx.fillStyle = unlocked ? (diffColors[def.difficulty] || '#888') : '#444';
    ctx.font = '13px monospace';
    ctx.fillText(unlocked ? def.difficulty : '---', 400, y + 8);

    if (hs) {
      ctx.fillStyle = '#44ee44';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(formatTime(hs.bestTime), 550, y + 8);

      const posColors = ['#ffd700', '#c0c0c0', '#cd7f32', '#888'];
      ctx.fillStyle = posColors[hs.bestPosition - 1] || '#888';
      ctx.fillText(`${hs.bestPosition}${getOrdinal(hs.bestPosition)}`, 700, y + 8);
    } else {
      ctx.fillStyle = '#444';
      ctx.font = '14px monospace';
      ctx.fillText(unlocked ? '-- : --' : '---', 550, y + 8);
      ctx.fillText('---', 700, y + 8);
    }
  }

  // Stats summary
  const completedTracks = Object.keys(progression.highscores).length;
  ctx.fillStyle = '#886644';
  ctx.font = '14px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(`Tracks Completed: ${completedTracks}/${TRACK_DEFS.length}  |  Total Money Earned: $${progression.totalWrenches}`, W / 2, H - 80);

  // Reset option
  ctx.fillStyle = '#553322';
  ctx.font = '12px monospace';
  ctx.fillText('Press DELETE to reset all progress', W / 2, H - 50);

  // Back
  ctx.fillStyle = '#886644';
  ctx.font = '16px monospace';
  ctx.fillText('PRESS ESC OR ENTER TO GO BACK', W / 2, H - 20);
  ctx.textAlign = 'left';
}

function formatTime(frames) {
  const totalSecs = Math.floor(frames / 60);
  const mins = Math.floor(totalSecs / 60);
  const secs = totalSecs % 60;
  const ms = Math.floor((frames % 60) / 60 * 100);
  return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
}

function getOrdinal(n) {
  if (n === 1) return 'st';
  if (n === 2) return 'nd';
  if (n === 3) return 'rd';
  return 'th';
}

// ========================================
// COUNTDOWN
// ========================================

function drawCountdown() {
  const count = Math.ceil(countdownTimer / 60);
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(W / 2 - 60, H / 2 - 50, 120, 100);
  ctx.fillStyle = count > 0 ? '#ff6600' : '#00ff00';
  ctx.font = 'bold 64px monospace';
  ctx.textAlign = 'center';
  ctx.fillText(count > 0 ? count.toString() : 'GO!', W / 2, H / 2 + 20);
  ctx.textAlign = 'left';
}

// ========================================
// RESULTS SCREEN
// ========================================

let raceRewardClaimed = false;
let lastRaceReward = 0;
let lastRacePosition = 0;
let isNewRecord = false;
let trackUnlocked = false;

function drawResults(cars) {
  ctx.fillStyle = 'rgba(0,0,0,0.85)';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.shadowColor = '#ff6600';
  ctx.shadowBlur = 15;
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 44px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('RACE COMPLETE', W / 2, 80);
  ctx.shadowBlur = 0;

  // Track name
  ctx.fillStyle = '#886644';
  ctx.font = '16px monospace';
  ctx.fillText(trackState.name, W / 2, 110);

  // Decorative line
  ctx.strokeStyle = '#663300';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(W / 2 - 250, 125);
  ctx.lineTo(W / 2 + 250, 125);
  ctx.stroke();

  const sorted = [...cars].sort((a, b) => {
    if (a.finished && b.finished) return a.finishTime - b.finishTime;
    if (a.finished) return -1;
    if (b.finished) return 1;
    return b.totalProgress - a.totalProgress;
  });

  // Position colors
  const posColors = ['#ffd700', '#c0c0c0', '#cd7f32', '#666'];

  // Results table
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#886644';
  ctx.fillText('POS', 200, 160);
  ctx.fillText('RACER', 260, 160);
  ctx.fillText('TIME', 500, 160);
  ctx.fillText('REWARD', 650, 160);

  ctx.strokeStyle = '#443322';
  ctx.beginPath();
  ctx.moveTo(190, 168);
  ctx.lineTo(750, 168);
  ctx.stroke();

  for (let i = 0; i < sorted.length; i++) {
    const c = sorted[i];
    const y = 195 + i * 45;
    const isP = c === player;
    const def = TRACK_DEFS[progression.currentTrackIndex] || TRACK_DEFS[0];
    const reward = def.reward[i] || 0;

    // Highlight player row
    if (isP) {
      ctx.fillStyle = 'rgba(255,102,0,0.15)';
      ctx.fillRect(185, y - 18, 575, 38);
      ctx.strokeStyle = '#ff6600';
      ctx.lineWidth = 1;
      ctx.strokeRect(185, y - 18, 575, 38);
    }

    // Position badge
    ctx.fillStyle = posColors[i] || '#666';
    ctx.font = 'bold 22px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`${i + 1}${getOrdinal(i + 1)}`, 200, y + 8);

    // Name
    ctx.fillStyle = c.color;
    ctx.font = 'bold 18px monospace';
    ctx.fillText(c.name, 260, y + 8);

    // Time
    const timeStr = c.finished ? formatTime(c.finishTime) : 'DNF';
    ctx.fillStyle = c.finished ? '#aaa' : '#663333';
    ctx.font = '16px monospace';
    ctx.fillText(timeStr, 500, y + 8);

    // Reward
    if (isP) {
      ctx.fillStyle = '#44ee44';
      ctx.font = 'bold 16px monospace';
      ctx.fillText(`+$${reward}`, 650, y + 8);
    }
  }

  // Player reward summary
  const playerIdx = sorted.indexOf(player);
  const def = TRACK_DEFS[progression.currentTrackIndex] || TRACK_DEFS[0];
  lastRaceReward = def.reward[playerIdx] || 0;
  lastRacePosition = playerIdx + 1;

  const summaryY = 400;
  ctx.fillStyle = 'rgba(30,30,25,0.8)';
  ctx.fillRect(200, summaryY - 10, 500, 90);
  ctx.strokeStyle = '#443322';
  ctx.lineWidth = 1;
  ctx.strokeRect(200, summaryY - 10, 500, 90);

  ctx.textAlign = 'center';
  ctx.fillStyle = '#44ee44';
  ctx.font = 'bold 22px monospace';
  ctx.fillText(`+$${lastRaceReward} EARNED`, W / 2, summaryY + 20);

  ctx.fillStyle = '#ccc';
  ctx.font = '14px monospace';
  ctx.fillText(`Position: ${lastRacePosition}${getOrdinal(lastRacePosition)}  |  Money: $${progression.money}`, W / 2, summaryY + 48);

  // New record indicator
  if (isNewRecord) {
    const blink = Math.floor(Date.now() / 250) % 2;
    ctx.fillStyle = blink ? '#ffd700' : '#ff9900';
    ctx.font = 'bold 20px monospace';
    ctx.fillText('*** NEW RECORD! ***', W / 2, summaryY + 72);
  }

  // Track unlocked indicator
  if (trackUnlocked) {
    const blink = Math.floor(Date.now() / 300) % 2;
    ctx.fillStyle = blink ? '#44ff44' : '#22aa22';
    ctx.font = 'bold 18px monospace';
    ctx.fillText('NEW TRACK UNLOCKED!', W / 2, summaryY + 100);
  }

  // Bottom options
  const optionY = trackUnlocked ? summaryY + 135 : summaryY + 115;

  // Check if player finished (can progress to next track)
  const canProgress = player.finished && progression.currentTrackIndex < TRACK_DEFS.length - 1
    && progression.currentTrackIndex + 1 < progression.unlockedTracks;

  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 18px monospace';
  ctx.fillText('ENTER - UPGRADE SHOP', W / 2, optionY);

  if (canProgress) {
    ctx.fillStyle = '#44aa44';
    ctx.fillText('N - NEXT TRACK', W / 2, optionY + 30);
  }

  ctx.fillStyle = '#886644';
  ctx.font = '14px monospace';
  ctx.fillText('R - Race Again  |  ESC - Main Menu', W / 2, optionY + 55);

  ctx.textAlign = 'left';
}

// ========================================
// SHOP SCREEN
// ========================================

function drawShop(player) {
  ctx.fillStyle = '#0a0a08';
  ctx.fillRect(0, 0, W, H);

  // Title
  ctx.shadowColor = '#ff6600';
  ctx.shadowBlur = 15;
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 36px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('UPGRADE SHOP', W / 2, 55);
  ctx.shadowBlur = 0;

  // Money display
  ctx.fillStyle = 'rgba(30,30,25,0.8)';
  ctx.fillRect(W / 2 - 150, 70, 300, 35);
  ctx.strokeStyle = '#443322';
  ctx.lineWidth = 1;
  ctx.strokeRect(W / 2 - 150, 70, 300, 35);

  ctx.fillStyle = '#44ee44';
  ctx.font = 'bold 18px monospace';
  ctx.fillText(`MONEY: $${progression.money}`, W / 2, 93);

  // Next track info
  ctx.fillStyle = '#886644';
  ctx.font = '13px monospace';
  const nextTrackName = TRACK_DEFS[progression.currentTrackIndex] ? TRACK_DEFS[progression.currentTrackIndex].name : '';
  ctx.fillText(`Next Race: ${nextTrackName}`, W / 2, 125);

  // Upgrade categories
  const upgrades = [
    { name: 'TOP SPEED', key: '1', cost: 2, current: player.speedUpgrade, max: 5, desc: '+0.3 max speed per level', cat: 'permanent' },
    { name: 'ACCELERATION', key: '2', cost: 2, current: player.accelUpgrade, max: 5, desc: '+0.01 acceleration per level', cat: 'permanent' },
    { name: 'TIRES/HANDLING', key: '3', cost: 2, current: player.tireUpgrade, max: 5, desc: '+0.005 turn speed per level', cat: 'permanent' },
    { name: 'AMMO PACK (+5)', key: '4', cost: 1, current: player.ammo, max: 99, desc: 'Cannon ammunition', cat: 'consumable' },
    { name: 'NITRO TANK (+1)', key: '5', cost: 3, current: player.nitro, max: 99, desc: 'Nitro boost charge', cat: 'consumable' },
    { name: 'MISSILE (+1)', key: '6', cost: 4, current: player.missiles, max: 99, desc: 'Homing missile', cat: 'consumable' },
  ];

  // Section: Permanent upgrades
  ctx.fillStyle = '#aa6633';
  ctx.font = 'bold 14px monospace';
  ctx.textAlign = 'left';
  ctx.fillText('VEHICLE UPGRADES', 130, 160);
  ctx.strokeStyle = '#443322';
  ctx.beginPath();
  ctx.moveTo(130, 168);
  ctx.lineTo(770, 168);
  ctx.stroke();

  for (let i = 0; i < 3; i++) {
    const u = upgrades[i];
    const y = 190 + i * 65;
    const canAfford = progression.money >= u.cost && u.current < u.max;
    const maxed = u.current >= u.max;

    // Card background
    ctx.fillStyle = canAfford ? 'rgba(40,35,20,0.8)' : 'rgba(20,20,15,0.6)';
    ctx.fillRect(120, y - 8, 660, 52);
    ctx.strokeStyle = canAfford ? '#665533' : '#332211';
    ctx.lineWidth = 1;
    ctx.strokeRect(120, y - 8, 660, 52);

    // Key indicator
    ctx.fillStyle = canAfford ? '#ff6600' : '#444';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`[${u.key}]`, 155, y + 20);

    // Name
    ctx.fillStyle = canAfford ? '#ff9933' : '#666';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(u.name, 190, y + 14);

    // Description
    ctx.fillStyle = '#555';
    ctx.font = '11px monospace';
    ctx.fillText(u.desc, 190, y + 32);

    // Upgrade bars
    const barX = 520;
    for (let j = 0; j < u.max; j++) {
      ctx.fillStyle = j < u.current ? '#ff6600' : '#2a2218';
      ctx.fillRect(barX + j * 28, y + 5, 22, 18);
      ctx.strokeStyle = j < u.current ? '#cc4400' : '#443322';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX + j * 28, y + 5, 22, 18);
    }

    // Cost
    ctx.textAlign = 'right';
    if (maxed) {
      ctx.fillStyle = '#44aa44';
      ctx.font = 'bold 14px monospace';
      ctx.fillText('MAX', 770, y + 20);
    } else {
      ctx.fillStyle = canAfford ? '#44ee44' : '#663333';
      ctx.font = '14px monospace';
      ctx.fillText(`$${u.cost}`, 770, y + 20);
    }
    ctx.textAlign = 'left';
  }

  // Section: Consumables
  ctx.fillStyle = '#aa6633';
  ctx.font = 'bold 14px monospace';
  ctx.fillText('SUPPLIES', 130, 395);
  ctx.strokeStyle = '#443322';
  ctx.beginPath();
  ctx.moveTo(130, 403);
  ctx.lineTo(770, 403);
  ctx.stroke();

  for (let i = 3; i < 6; i++) {
    const u = upgrades[i];
    const y = 420 + (i - 3) * 55;
    const canAfford = progression.money >= u.cost;

    // Card background
    ctx.fillStyle = canAfford ? 'rgba(40,35,20,0.8)' : 'rgba(20,20,15,0.6)';
    ctx.fillRect(120, y - 8, 660, 42);
    ctx.strokeStyle = canAfford ? '#665533' : '#332211';
    ctx.lineWidth = 1;
    ctx.strokeRect(120, y - 8, 660, 42);

    // Key indicator
    ctx.fillStyle = canAfford ? '#ff6600' : '#444';
    ctx.font = 'bold 20px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`[${u.key}]`, 155, y + 18);

    // Name
    ctx.fillStyle = canAfford ? '#ff9933' : '#666';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(u.name, 190, y + 14);

    // Description + current stock
    ctx.fillStyle = '#555';
    ctx.font = '11px monospace';
    ctx.fillText(`${u.desc}  |  In stock: ${u.current}`, 190, y + 30);

    // Cost
    ctx.textAlign = 'right';
    ctx.fillStyle = canAfford ? '#44ee44' : '#663333';
    ctx.font = '14px monospace';
    ctx.fillText(`$${u.cost}`, 770, y + 18);
    ctx.textAlign = 'left';
  }

  // Bottom controls
  ctx.fillStyle = '#ff6600';
  ctx.font = 'bold 18px monospace';
  ctx.textAlign = 'center';
  ctx.fillText('PRESS ENTER TO START RACE', W / 2, 610);

  ctx.fillStyle = '#554433';
  ctx.font = '12px monospace';
  ctx.fillText('ESC - Back to Menu', W / 2, 640);
  ctx.textAlign = 'left';
}

// ========================================
// INITIALIZE GAME
// ========================================

const player = new Car('#cc3300', 'PLAYER', true);
const ai1 = new Car('#3366cc', 'VIPER', false);
const ai2 = new Car('#33aa33', 'SKULL', false);
const ai3 = new Car('#aa33aa', 'GRIM', false);
const cars = [player, ai1, ai2, ai3];

// Generate default track on startup
generateDefaultTrack();

function resetRace() {
  for (let i = 0; i < cars.length; i++) {
    cars[i].reset(i);
  }
  bullets = [];
  explosions = [];
  raceTime = 0;
  raceRewardClaimed = false;
  isNewRecord = false;
  trackUnlocked = false;
  generateObstacles();
}

// ========================================
// INPUT HANDLING
// ========================================

const keys = {};
document.addEventListener('keydown', e => {
  // Prevent browser defaults for game keys (scrolling, etc.)
  const gameKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'Enter', 'Escape'];
  if (gameKeys.includes(e.key)) {
    e.preventDefault();
  }
  keys[e.key] = true;

  // --- MENU STATE ---
  if (gameState === STATE.MENU) {
    if (e.key === 'ArrowUp' || e.key === 'w') {
      menuSelection = Math.max(0, menuSelection - 1);
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      menuSelection = Math.min(1, menuSelection + 1);
    }
    if (e.key === 'Enter') {
      if (menuSelection === 0) {
        // Go to track select
        gameState = STATE.TRACK_SELECT;
        trackSelectCursor = progression.currentTrackIndex;
      } else if (menuSelection === 1) {
        // Go to highscores
        gameState = STATE.HIGHSCORES;
      }
    }
    if (e.key === 'l' || e.key === 'L') {
      document.getElementById('track-file-input').click();
    }
  }

  // --- TRACK SELECT STATE ---
  else if (gameState === STATE.TRACK_SELECT) {
    if (e.key === 'ArrowUp' || e.key === 'w') {
      trackSelectCursor = Math.max(0, trackSelectCursor - 1);
    }
    if (e.key === 'ArrowDown' || e.key === 's') {
      trackSelectCursor = Math.min(TRACK_DEFS.length - 1, trackSelectCursor + 1);
    }
    if (e.key === 'Enter') {
      if (trackSelectCursor < progression.unlockedTracks) {
        // Select this track and go to shop
        progression.currentTrackIndex = trackSelectCursor;
        generateTrackFromDef(progression.currentTrackIndex);
        gameState = STATE.SHOP;
      }
    }
    if (e.key === 'Escape') {
      gameState = STATE.MENU;
    }
  }

  // --- HIGHSCORES STATE ---
  else if (gameState === STATE.HIGHSCORES) {
    if (e.key === 'Escape' || e.key === 'Enter') {
      gameState = STATE.MENU;
    }
    if (e.key === 'Delete') {
      // Reset all progress
      progression = {
        currentTrackIndex: 0,
        unlockedTracks: 1,
        totalWrenches: 0,
        money: 0,
        highscores: {}
      };
      player.speedUpgrade = 0;
      player.accelUpgrade = 0;
      player.tireUpgrade = 0;
      player.wrenches = 0;
      saveProgress();
    }
  }

  // --- RESULTS STATE ---
  else if (gameState === STATE.RESULTS) {
    if (e.key === 'Enter') {
      // Claim reward and go to shop
      claimRaceReward();
      gameState = STATE.SHOP;
    } else if (e.key === 'r' || e.key === 'R') {
      claimRaceReward();
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
    } else if (e.key === 'n' || e.key === 'N') {
      // Next track
      if (player.finished && progression.currentTrackIndex < TRACK_DEFS.length - 1
          && progression.currentTrackIndex + 1 < progression.unlockedTracks) {
        claimRaceReward();
        progression.currentTrackIndex++;
        generateTrackFromDef(progression.currentTrackIndex);
        gameState = STATE.SHOP;
      }
    } else if (e.key === 'Escape') {
      claimRaceReward();
      gameState = STATE.MENU;
    }
  }

  // --- SHOP STATE ---
  else if (gameState === STATE.SHOP) {
    if (e.key === 'Enter') {
      generateTrackFromDef(progression.currentTrackIndex);
      gameState = STATE.COUNTDOWN;
      countdownTimer = 240;
      resetRace();
      saveProgress();
    }
    if (e.key === 'Escape') {
      saveProgress();
      gameState = STATE.MENU;
    }
    // Permanent upgrades cost money from progression
    if (e.key === '1' && progression.money >= 2 && player.speedUpgrade < 5) {
      player.speedUpgrade++;
      progression.money -= 2;
      saveProgress();
    }
    if (e.key === '2' && progression.money >= 2 && player.accelUpgrade < 5) {
      player.accelUpgrade++;
      progression.money -= 2;
      saveProgress();
    }
    if (e.key === '3' && progression.money >= 2 && player.tireUpgrade < 5) {
      player.tireUpgrade++;
      progression.money -= 2;
      saveProgress();
    }
    // Consumables
    if (e.key === '4' && progression.money >= 1) {
      player.ammo += 5;
      progression.money -= 1;
      saveProgress();
    }
    if (e.key === '5' && progression.money >= 3) {
      player.nitro++;
      progression.money -= 3;
      saveProgress();
    }
    if (e.key === '6' && progression.money >= 4) {
      player.missiles++;
      progression.money -= 4;
      saveProgress();
    }
  }
});
document.addEventListener('keyup', e => { keys[e.key] = false; });

// --- Claim race reward helper ---
function claimRaceReward() {
  if (raceRewardClaimed) return;
  raceRewardClaimed = true;

  const sorted = [...cars].sort((a, b) => {
    if (a.finished && b.finished) return a.finishTime - b.finishTime;
    if (a.finished) return -1;
    if (b.finished) return 1;
    return b.totalProgress - a.totalProgress;
  });

  const playerIdx = sorted.indexOf(player);
  const def = TRACK_DEFS[progression.currentTrackIndex] || TRACK_DEFS[0];
  const reward = def.reward[playerIdx] || 0;

  // Add money
  progression.money += reward;
  progression.totalWrenches += reward;

  // Save highscore
  const trackName = trackState.name;
  const existing = progression.highscores[trackName];
  isNewRecord = false;

  if (player.finished) {
    if (!existing || player.finishTime < existing.bestTime) {
      progression.highscores[trackName] = {
        bestTime: player.finishTime,
        bestPosition: playerIdx + 1
      };
      isNewRecord = true;
    } else if (playerIdx + 1 < existing.bestPosition) {
      existing.bestPosition = playerIdx + 1;
    }

    // Unlock next track if player finished (any position)
    if (progression.currentTrackIndex + 1 >= progression.unlockedTracks
        && progression.currentTrackIndex + 1 < TRACK_DEFS.length) {
      progression.unlockedTracks = progression.currentTrackIndex + 2;
      trackUnlocked = true;
    } else {
      trackUnlocked = false;
    }
  } else {
    trackUnlocked = false;
  }

  saveProgress();
}

// ========================================
// MAIN GAME LOOP
// ========================================

function gameLoop() {
  ctx.clearRect(0, 0, W, H);

  switch (gameState) {
    case STATE.MENU:
      drawMenu();
      break;

    case STATE.TRACK_SELECT:
      drawTrackSelect();
      break;

    case STATE.HIGHSCORES:
      drawHighscores();
      break;

    case STATE.COUNTDOWN:
      drawTrack();
      drawObstacles();
      for (const c of cars) c.draw(ctx);
      drawHUD(player, cars);
      drawCountdown();
      countdownTimer--;
      if (countdownTimer <= -60) {
        gameState = STATE.RACING;
      }
      break;

    case STATE.RACING:
      raceTime++;

      // Update
      for (const c of cars) {
        c.update(keys, 1, cars, bullets);
      }
      updateBullets(cars);

      // Check race end
      const allFinishedOrTimeout = cars.every(c => c.finished) || raceTime > 60 * 60 * 5;
      if (player.finished || allFinishedOrTimeout) {
        if (!player._resultDelay) player._resultDelay = 120;
        player._resultDelay--;
        if (player._resultDelay <= 0) {
          gameState = STATE.RESULTS;
          raceRewardClaimed = false;
          player._resultDelay = 0;
        }
      }

      // Draw
      drawTrack();
      drawObstacles();
      drawBullets();
      for (const c of cars) c.draw(ctx);
      drawExplosions();
      drawHUD(player, cars);
      break;

    case STATE.RESULTS:
      drawResults(cars);
      break;

    case STATE.SHOP:
      drawShop(player);
      break;
  }

  requestAnimationFrame(gameLoop);
}

// --- Load saved progress and apply ---
loadProgress();
if (pendingUpgrades) {
  player.speedUpgrade = pendingUpgrades.speed || 0;
  player.accelUpgrade = pendingUpgrades.accel || 0;
  player.tireUpgrade = pendingUpgrades.tires || 0;
  player.wrenches = pendingUpgrades.wrenches || 0;
  player.applyUpgrades();
  pendingUpgrades = null;
}

// Start
gameLoop();
</script>
</body>
</html>
